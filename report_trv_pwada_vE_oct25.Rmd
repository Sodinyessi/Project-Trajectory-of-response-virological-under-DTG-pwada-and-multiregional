---
title: "\\textbf{IeDEA pwada - regionaL project}"
author: "Sophie Desmonde$^{1}$, \\textbf{Emile Sodinyessi*}$^{1}$,\ \n Valériane Leroy$^{1}$  \non behalf of the IeDEA West Africa Collaboration\n"
output:
  pdf_document:
    keep_md: true
    number_sections: true
  html_document:
    df_print: paged
always_allow_html: true
header-includes:
  - \usepackage{tikz}
  - \usetikzlibrary{arrows.meta, positioning}
---

\begin{center}
  \hrulefill

  \vspace{0.4em}
  \textbf{24-MONTH HIV VIRAL LOAD TRENDS SINCE DOLUTEGRAVIR INITIATION AMONG CHILDREN AND ADOLESCENTS 0-19 YEARS LIVING WITH HIV}\\[0.5em]
  
  \vspace{0.2em}
  \hrulefill
\end{center}
	
\begin{center}
{\small
$^1$University of Toulouse, National Institute for Health and Medical Research (INSERM) UMR 1219, Centre d'Epidémiologie et de Recherche en santé des POPulations (CERPOP), Toulouse, France.\\
$^2$Korle Bu Teaching Hospital (KBTH), Accra, Ghana.\\
$^3$National Institute of Medical Research (NIMR), Lagos, Nigeria.\\
$^4$Centre de Prise en Charge, de Recherche et de Formation (CEPREF Enfant), Abidjan, Côte d'Ivoire.\\
$^5$Cocody University Hospital, Pediatric Department (CHUC), Abidjan, Côte d'Ivoire.\\
$^6$Gabriel Toure Children's Hospital (GABRIEL), Bamako, Mali.\\
$^7$Centre Intégré de Recherche Bioclinique d'Abidjan (CIRBA), Abidjan, Côte d'Ivoire.\\
$^8$Centre National Hospitalier Universitaire (CNHU), Cotonou, Bénin.\\
$^9$Yalgado Ouédraogo University Hospital (YALGADO), Ouagadougou, Burkina Faso.\\
$^{10}$Bordeaux Population Health - Global Health in the Global South (GHiGS), Université de Bordeaux.\\
$^{11}$Federal Medical Center - Abeokuta (ABEOKUTA), Ogun, Nigeria.\\
$^{12}$State Specialist Hospital - Akure (AKURE), Ondo, Nigeria.\\
$^{13}$Jos University Teaching Hospital (JOS), Plateau, Nigeria.\\
$^{14}$Federal Medical Center - Makurdi (MAKURDI), Benue, Nigeria.\\
$^{15}$University College Hospital (UCH), Oyo, Nigeria.\\
$^{16}$CHUY Centre Hospitalier Universitaire de Yopougon (CHUY), Abidjan, Côte d'Ivoire.\\
$^{17}$Centre Hospitalier Universitaire de Tokoin (TOKOIN), Lomé, Togo.
}
\end{center}

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,        # No code
  message = FALSE,     # No messages 
  warning = FALSE,     # No warnings
  results = 'markup'   # seuls les resultats sont affichés
)
```

```{r fig.align='center', out.width='100%'}
knitr::include_graphics("C:/Users/Emile/Desktop/desc_imag_iedea/imag00.png") 
```

```{r}
# Load the readr package (part of tidyverse)
library(readr)
library(dplyr)
library(lubridate)
library(stringr)
library(tidyr)

# Les packages nécessaires 
library(VIM) # selc_var
library(ggplot2) #graphiq
library(tidyverse) #manip
library(haven)
library(kableExtra)
library(corrplot)
library(ggrepel)
library(tibble) #manip
library(caret) #model machine learning
library(survival) # pour les modèles de survie :: coxph function of model_cox
library(survey) # Analyse de survie :: longi
library(srvyr)
library(marginaleffects)
library(networkD3) # Pour le diagramme de Sankey
library(gtsummary) # Descritpion de la population
library(gt)
library(questionr) #freq and others
library(bslib)
library(shiny) # pour nécessité avec esquisse
library(esquisse) # Graphics bivary
#library(nnet) # Pour la régression multinomiale
library(labelled)
library(lcmm) #for model class latente
library(flexmix) 
library(randomLCA)
#rm(list = ls())
library(janitor)
library(webshot2)
library(data.table)
library(tools)

library(future)
library(furrr)
#plan(multisession, workers = 4)  # une configuration R pour exécuter des calculs en parallèle sur 4 cœurs de l'ordinateur. Pour des calculs lourd.
library(tableone) #For "CreateTableOne"
library(openxlsx) # For "write.xlsx()"
library(officer) # For "body_add_par"
library(flextable)
```

```{r}
set.seed(1234567)  # Jeu de données aléatoires pour la répétabilité des résultats
```

```{r message=FALSE, warning=FALSE, include=FALSE}
#Import data
chemin_apin <- "C:/Users/Emile/Desktop/IeDEA/MERGER 9/IeDEA M9 09oct25"
fichiers_apin <- list.files(path = chemin_apin, pattern = "\\.sas7bdat$", full.names = TRUE)
wa_apin_tbl <- lapply(fichiers_apin, read_sas)
names(wa_apin_tbl) <- file_path_sans_ext(basename(fichiers_apin))

#After having completed by hand in excel the coding of each art_id re-import the file and merge
artx_bis <- read.csv2("C:/Users/Emile/Desktop/IeDEA/projet réponse virologique/TRV pwada vEmile Sept25/File TRV pwada vEmile Sept25/bdd TRV pwada/art_ids_missing_arvtx.csv")

wa_apin_lower <- lapply(wa_apin_tbl, \(x) rename_with(x, tolower)) #Environnement & rename columns
names(wa_apin_lower) <- paste0("wa_apin_", names(wa_apin_lower))
list2env(wa_apin_lower, envir = .GlobalEnv)
```


```{r message=FALSE, warning=FALSE, include=FALSE}
wa_apin_full_m9_ped_apin <- wa_apin_full_m9_ped_apin %>% arrange(patient, program)
wa_apin_tblbas <- wa_apin_tblbas %>% arrange(patient, program)
wa_apin_tblltfu <- wa_apin_tblltfu %>% arrange(patient, program)

wa_apin_tblbas$censure24 <- wa_apin_full_m9_ped_apin$censure24
wa_apin_tblltfu$censure24 <- wa_apin_full_m9_ped_apin$censure24
```


```{r fig.align='center', out.width='75%'}
knitr::include_graphics("C:/Users/Emile/Desktop/desc_imag_iedea/Image01.png")
#\begin{center}\textbf{15 Pediatric cohorts in 7 countries for the 4th round}\end{center}
```
\newpage
\tableofcontents
\newpage
\section{Introduction}

Dolutegravir (DTG) has become the cornerstone of antiretroviral therapy (ART) for children and adolescents living with HIV in recent years. Its potent antiviral efficacy, high genetic barrier to resistance, and convenient once-daily dosing have made it the preferred regimen in pediatric treatment guidelines. Despite its widespread adoption, few studies have comprehensively documented the long-term dynamics of virological response among this population—particularly in real-world settings, where patient profiles and follow-up conditions differ substantially from those observed in clinical trials.

Understanding long-term viral load trajectories is essential to assess the sustained effectiveness of DTG-based ART in children and adolescents. This study investigates 24-month trends in HIV viral load following DTG initiation among individuals aged 0–19 years, using data from the multiregional IeDEA (International epidemiology Databases to Evaluate AIDS) consortium. Eligible participants included children and adolescents who initiated or switched to a DTG-containing regimen and remained on therapy for at least six months. Patients with missing or implausible DTG initiation dates were excluded to ensure data accuracy and reliability.

The analysis draws on data from 15 clinical sites across seven West African countries—Benin, Côte d’Ivoire, Ghana, Togo, Mali, Burkina Faso, and Nigeria—including five APIN-supported sites in Nigeria. To better characterize the heterogeneity in virological trajectories, latent classification methods can be employed to identify subgroups of patients following distinct response patterns. In R, such approaches can be implemented using packages such as FlexMix, which fits group-based trajectory models without random effects, and randomLCA, which allows for individual-level variability within latent classes. Together, these complementary tools provide a robust framework for analyzing complex longitudinal data in pediatric HIV research.


\subsection{Background}
\begin{itemize}
\item Dolutegravir (DTG) has become a preferred antiretroviral therapy (ART) option for children and adolescents living with HIV due to its high potency, favorable resistance profile, and once-daily dosing. 
\item However, data on virological response in this population remain limited in real-world settings.
\end{itemize}

\subsection{Objective}
\begin{itemize}
\item To describe patterns of virological response to DTG-based ART in a cohort of children and adolescents living with HIV in West Africa.
\end{itemize}

\subsection{Methods}

All CALHIV aged 0 to 19 years initiating DTG-based ART between 2019--2023 and enrolled in the West African pediatric International epidemiological Database for Evaluating AIDS (IeDEA pWADA) were included.

\subsubsection{Follow-up}
Participants were followed for a period of 24 months from the date of dolutegravir (DTG) initiation, considered as the baseline, to evaluate longitudinal virological outcomes over time.

\subsubsection{Baseline viral load (VL)}
Baseline viral load was defined as the closest measurement within six months prior to, or up to two weeks after, DTG initiation. Virological categories \textbf{Undetectable}, \textbf{Low-level viremia}, and \textbf{Viral Failure} were assessed at baseline (M0, -6 months to +14 days) and during follow-up at M6 ($\pm$ 3 months), M12, and M24 ($\pm$ 6 months) to track patients' virological trajectories.

\newpage
\subsubsection{Definitions}
\begin{table}[h!]
\centering
\begin{tabular}{ccc}
\hline
\textbf{category} & \textbf{symboL} & \textbf{definition (copies/mL)} \\
\hline
Viral suppression & VS & $<$ 200 \\
Low-level viremia & LLV & 200 -- 999 \\
Viral failure & VF & >= 1000 \\
\hline
\end{tabular}
\end{table}
\begin{center}
\textbf{HIV viral load categories}
\end{center}

\newpage
\begin{landscape}
\subsubsection{Statistical analysis}
\begin{itemize}
    \item \textbf{Group-based trajectory modelling (GBTM):} Assigns each CALHIV to a group based on their VL across visits during follow-up.
    \item \textbf{Logistic trajectory modelling:} Identifies groups with similar longitudinal patterns of viremia based on detectable or undetectable VL at a 1000-copy threshold.
    \item \textbf{Multinomial regression analysis:} Adjusted for age, sex, and program to identify factors associated with each VL trajectory.
\end{itemize}

\begin{table}[h!]
\centering
\begin{tabular}{lll}
\hline
\textbf{} & \textbf{FlexMix} & \textbf{randomLCA} \\
\hline
Type of model & Finite mixture model -- Group Based Trajectory Model (GBTM) & Probabilistic latent class model \\
Algorithm & Expectation-Maximization & Maximum likelihood estimation \\
Random effects & No & Random intercept to account for inter-individual variability \\
Time & Continuous variable, modelled quadratically & Continuous variable, modelled quadratically \\
\hline
\end{tabular}
\end{table}
\begin{center}
\textbf{Les deux (02) approches FlexMix et randomLCA pour la classification des patients selon l’évolution de leur charge virale.}
\end{center}

\begin{itemize}
  \item \textbf{FlexMix (GBTM Model) : } Implemented using the \textbf{FlexMix} function. 
  The estimation relies on the Expectation-Maximization (EM) algorithm and does not account for random effects, 
  assuming that the variability in trajectories is fully explained by the membership to latent classes.
  
  \item \textbf{randomLCA (Latent Class Mixed Model) : } Estimated via maximum likelihood using the \textbf{randomLCA} function.
  This model incorporates random effects to capture inter-individual variability within each latent class, 
  providing a more flexible framework for modeling longitudinal trajectories.
\end{itemize}
\end{landscape}


\newpage
\section{Flow chart of the study population}

\begin{figure}[h!]
\centering
\begin{tikzpicture}[
    node distance=1.5cm and 0.9cm,
    every node/.style={
        align=center,
        minimum width=14cm,
        minimum height=1.5cm,
        inner sep=5pt,
        append after command={
            \pgfextra{
                \draw[thick] (\tikzlastnode.north west) -- (\tikzlastnode.north east);
                \draw[thick] (\tikzlastnode.south west) -- (\tikzlastnode.south east);
            }
        }
    },
    arrow/.style={-Stealth, thick}
]

\node (top) {All IeDEA Database \\ $$N = 30,913$$};

\node [below=of top, minimum width=10cm, minimum height=1.5cm] (included) {ART INTIATION \\ $$N = 13,839$$};

\node [below=of included, minimum width=10cm, minimum height=1.5cm] (switch) {who initiated DTG-based treatment \\ $$N = 5,095$$};

\node [below=of switch, minimum width=10cm, minimum height=1.5cm] (outcome) {under DTG included for the study \\ age\_art\_init < 19 years \\ $$N = 4,091$$ \\ 48\,\% FeMale};

\node [below=of outcome, minimum width=4cm, minimum height=5cm] (centres) {
\begin{tabular}{ll}
ABEOKUTA  & 158  \\
AKURE     & 347  \\
\textbf{CEPREF}    & 288  \\
\textbf{CHUC}      & 225  \\
\textbf{CHUY}      & 270  \\
\textbf{CIRBA}     & 260  \\
\textbf{CNHU}      & 202  \\
\textbf{GABRIEL}   & 472  \\
JOS       & 362  \\
\textbf{KBTH}      & 129  \\
MAKURDI   & 671  \\
\textbf{NIMR}      & 150  \\
\textbf{TOKOIN}    & 70   \\
UCH       & 306  \\
\textbf{YALGADO}   & 181
\end{tabular}
};

\draw [arrow] (top.south) -- (included.north);
\draw [arrow] (included.south) -- (switch.north);
\draw [arrow] (switch.south) -- (outcome.north);
\draw [arrow] (outcome.south) -- (centres.north);

\end{tikzpicture}
\end{figure}

```{r message=FALSE, warning=FALSE, include=FALSE}
#Update art_selected with the name of art_ids
tblart_clean <- wa_apin_tblart %>%
  left_join(
    artx_bis %>% select(art_id, arvtx_bis),
    by = "art_id"
  )

#See if they all have arvtx_bis
tblart_clean %>%
  filter(is.na(arvtx_bis) | arvtx_bis == "") %>%
  distinct(art_id) %>%
  pull(art_id)
#Complete manually
tblart_clean <- tblart_clean %>%
  mutate(
    arvtx_bis = case_when(
      art_id == "J05AE03-L" ~ "RTV",
      art_id == "J05AE02" ~ "IDV",
      art_id == "J05AE03-H" ~ "RTV",
      art_id == "J05AF10" ~ "ETVr",
      art_id == "J05AF" ~ "NRTI_unspecified",
      art_id == "J05A" ~ "Unknown",
      art_id == "J05AG-BIC" ~ "BIC",
      art_id == "J05AE05" ~ "APV",
      art_id == "J05AE01-SQH" ~ "SQV",
      art_id == "J05AE07" ~ "FPV",  #Fos-amprenavir (PI)
      art_id == "J05AF03" ~ "ddC",
      art_id == "J05AX-VIC" ~ "Vicriviroc",
      art_id == "J05AG-CPV" ~ "CPV",  #NNRTI
      art_id == "J05A-PBT" ~ "Unknown",  #blind trial
      art_id == "L01XX05" ~ "Litalir", #Other
      art_id == "J05AR08" ~ "FTC+TDF+RPV",

      TRUE ~ arvtx_bis
    )
  )

#create ART regimen variable
tblart_clean  <- tblart_clean  %>%
  group_by(patient, art_sd) %>%
  mutate(
    arvtx_fixed = paste(sort(na.omit(unique(arvtx_bis))), collapse = "+")
  ) %>%
  ungroup()



#Delete duplicates of drugs in the same arvtx_fixed entry
tblart_clean <- tblart_clean %>%
  mutate(arvtx_fixed = sapply(strsplit(arvtx_fixed, "\\+"), function(drugs) {
    cleaned <- unique(trimws(drugs))           # remove duplicates + trim whitespace
    paste(cleaned, collapse = "+")             # rejoin into string
  }))

#Check if same combination is there twice but in different order and put all in same order
tblart_clean <- tblart_clean %>%
  mutate(arvtx_fixed = sapply(strsplit(arvtx_fixed, "\\+"), function(drugs) {
    cleaned <- sort(unique(trimws(drugs)))   # remove duplicates + sort alphabetically
    paste(cleaned, collapse = "+")
  }))

#Different regimens:
arvtx_table <- tblart_clean  %>%
  count(arvtx_fixed, sort = TRUE)
print(arvtx_table, n = nrow(arvtx_table))  # prints the whole table


#Define treatment class
nrtis   <- c("3TC", "ABC", "AZT", "FTC", "TDF", "TAF", "ddI", "d4T", "NRTI_unspecified", "ddC")
pis     <- c("LPV/r", "ATV", "ATV/r", "DRV", "DRV/r", "NFV", "IDV", "SQV", "TPV", "APV", "FPV", "PI_unspecified")
instis  <- c("DTG", "BIC", "RAL")
nnrtis  <- c("EFV", "NVP", "RPV", "ETV", "ETVr", "DLV", "CPV","NNRTI_unspecified")
entry_fusion <- c("Maraviroc", "Enfurvirtide", "Vicriviroc")
boosters <- c("RTV", "Cobicistat")
anchors <- c("DTG", "BIC", "RAL","LPV/r", "ATV", "ATV/r", 
             "DRV", "DRV/r", "NFV", "IDV", "SQV", "TPV", "APV", "FPV", "PI_unspecified", 
             "EFV", "NVP", "RPV", "ETV", "ETVr", "DLV", "CPV","NNRTI_unspecified",
             "Maraviroc", "Enfurvirtide", "Vicriviroc" )

#Scan suspect regimens
#They include more than one anchor drug class (e.g., INSTI + PI + NNRTI)
  #Except DRV+DTG, DRV + RAL, DTG+ETV, DTG+RPV and DRV+ETV =>plausible salvage therapies
#They include more than 2 NRTIs
  #Allow if there are exactly 3 NRTIs, and no PIs, NNRTIs, or INSTIs => plausible salvage
#They include multiple drugs from same class (e.g., EFV + NVP both NNRTIs)
#Less than 2 NRTIs only are classified as ambigous
#Anything else is a likely data arror but needs verifying

tblart_clean <- tblart_clean %>%
  mutate(
    drug_list = strsplit(arvtx_fixed, "\\+"),
    
    n_nrtis  = sapply(drug_list, function(d) sum(trimws(d) %in% nrtis)),
    n_instis = sapply(drug_list, function(d) sum(trimws(d) %in% instis)),
    n_nnrtis = sapply(drug_list, function(d) sum(trimws(d) %in% nnrtis)),
    n_pis    = sapply(drug_list, function(d) sum(trimws(d) %in% pis)),
    
    anchor_count = (n_instis > 0) + (n_nnrtis > 0) + (n_pis > 0),
    
    has_dtg = sapply(drug_list, function(d) "DTG" %in% trimws(d)),
    has_drv = sapply(drug_list, function(d) any(trimws(d) %in% c("DRV", "DRV/r"))),
    has_etv = sapply(drug_list, function(d) any(trimws(d) %in% c("ETV", "ETVr"))),
    has_rpv = sapply(drug_list, function(d) "RPV" %in% trimws(d)),
    n_total = sapply(drug_list, length),
    
    # Flag suspect regimens based on simplified rules
    flag_suspect = n_nrtis > 2 | anchor_count > 1,
    
    # Unified classification
    regimen_classification = case_when(
      !flag_suspect                                           ~ "Non-suspect",
      has_dtg & has_drv & anchor_count == 2 & n_nrtis >= 2    ~ "Plausible Salvage",
      has_dtg & has_etv & anchor_count == 2 & n_nrtis >= 2    ~ "Plausible Salvage",
      has_drv & has_etv & anchor_count == 2 & n_nrtis >= 2    ~ "Plausible Salvage",
      has_dtg & has_rpv & anchor_count == 2                   ~ "Plausible Salvage",
      n_nrtis == 3 & anchor_count == 0                        ~ "Plausible Salvage",
      anchor_count == 2 & n_nrtis >= 2                        ~ "Ambiguous",
      TRUE                                                    ~ "Likely Data Error"
    )
  )


tblart_clean <- tblart_clean %>%
  select( -drug_list, -n_nrtis, -n_instis, -n_nnrtis, -n_pis,
          -anchor_count, -has_dtg, -has_drv, -has_etv, -has_rpv, -n_total,
          -flag_suspect)

wa_apin_tblart_clean <- tblart_clean

#Delete intermediate tables
#rm(list = setdiff(ls(), "wa_apin_tblart_clean"))
```


```{r message=FALSE, warning=FALSE, include=FALSE}
## Sélection de la population selon les critères d'inclusion

## Total number of rows (i.e., individuals or observations)
wa_apin_tblbas %>%
  distinct(patient, program) %>%   # Only keep unique patient-region pairs
  count(program, name = "n_unique_patients")  # Count per region


#Delete rows with same patient, art_sd and arvtx_fixed: only keep one
wa_apin_tblart_clean_1 <- wa_apin_tblart_clean %>%
  distinct(patient, art_sd, arvtx_fixed, .keep_all = TRUE)

#Select first DTG prescription and date in wa_apin_tblart_clean;

wa_apin_tblart_clean_1 <- wa_apin_tblart_clean_1 %>%
  group_by(patient) %>%
  mutate(
    has_dtg = grepl("\\bDTG\\b", arvtx_fixed),
    dtg_sd = if (any(has_dtg)) min(art_sd[has_dtg]) else as.Date(NA),
    first_dtg = ifelse(has_dtg & art_sd == dtg_sd, 1, 0)
  ) %>%
  ungroup()

#Number of patients who intiated DTG
wa_apin_tblbas %>%
  inner_join(
    wa_apin_tblart_clean_1 %>% 
      filter(first_dtg == 1) %>% 
      distinct(patient), 
    by = "patient"
  ) %>%
  count(program, name = "n_dtg_patients")

#Delete patients who did not initiate DTG
wa_apin_tblart_dtgonly <- wa_apin_tblart_clean_1 %>%
  semi_join(
    wa_apin_tblart_clean_1 %>% filter(first_dtg == 1) %>% distinct(patient),
    by = "patient"
  )

wa_apin_tblart_dtgonly %>%
  distinct(patient) %>%
  count()


#Flag suspect regimens
wa_apin_tblart_clean_1 <- wa_apin_tblart_dtgonly %>%
  mutate(
    suspect_first_dtg = if_else(
      first_dtg == 1 & regimen_classification %in% c("Ambiguous", "Likely Data Error"),
      1, 0
    )
  )

#Count by region how many are suspect
wa_apin_tblart_clean_1 %>%
  group_by(program) %>%
  summarise(n_suspect_dtg = sum(suspect_first_dtg, na.rm = TRUE)) %>%
  arrange(desc(n_suspect_dtg))

#Create table with suspect regimens
suspect_dtg_regimens <- wa_apin_tblart_clean_1 %>%
  filter(suspect_first_dtg == 1)

#Delete children with suspect DTG regimens
# Identify patient IDs with a suspect first DTG
suspect_patients <- wa_apin_tblart_clean_1 %>%
  filter(first_dtg == 1 & suspect_first_dtg == 1) %>%
  pull(patient)
# Remove all observations related to those patients
wa_apin_tblart_nosuspect <- wa_apin_tblart_clean_1 %>%
  filter(!patient %in% suspect_patients)

#Number of patients who intiated DTG
wa_apin_tblart_nosuspect %>%
  distinct(patient, program) %>%
  count(program, name = "n_patients")


#Since 2018
wa_apin_tblart_nosuspect <- wa_apin_tblart_nosuspect %>%
  semi_join(
    wa_apin_tblart_nosuspect %>%
      filter(first_dtg == 1, art_sd >= as.Date("2018-01-01")) %>%
      distinct(patient),
    by = "patient"
  )

#Number of patients who intiated DTG
wa_apin_tblart_nosuspect %>%
  distinct(patient, program) %>%
  count(program, name = "n_patients")

#Aged 0-19 years at DTG initiation
# Make sure dates are in Date format
wa_apin_tblbas <- wa_apin_tblbas %>%
  mutate(birth_d = as.Date(birth_d))  
dtg_since_2018 <- wa_apin_tblart_nosuspect %>%
  mutate(art_sd = as.Date(art_sd))

# Calculate age at DTG initiation
# Filter for patients aged 0–19 at DTG start
wa_apin_tblart_0_19 <- dtg_since_2018 %>%
  inner_join(wa_apin_tblbas %>% select(patient, birth_d), by = "patient") %>%
  mutate(age_at_dtg = floor(interval(birth_d, dtg_sd) / years(1))) %>%
  filter(age_at_dtg >= 0, age_at_dtg <= 19)

#Keep only first DTG line
tblart_first_dtg <- wa_apin_tblart_0_19 %>%
  filter(first_dtg == 1)

# Add all baseline variables to dtg_0_19
wa_apin_dtg_0_19_full <- tblart_first_dtg %>%
  select(-program, -birth_d) %>%  # remove if already present
  left_join(wa_apin_tblbas, by = "patient")
#Number of patients who intiated DTG
wa_apin_dtg_0_19_full %>%
  distinct(patient, program) %>%
  count(program, name = "n_patients")
aa <- wa_apin_dtg_0_19_full
aa %>%
  distinct(patient) %>%
  count(name = "n_patients")
```

```{r message=FALSE, warning=FALSE, include=FALSE}
##Suivi des patients

#Add close_d to wa_apin_tblbas
wa_apin_tblbas <- wa_apin_tblbas %>%
  left_join(
    wa_apin_tblcenter %>% select(program, close_d),
    by = "program"
  )
#End date = date of DTG discontinuation
#First select a table with only ART since DTG initiation for each patient
# Ensure dates are Date type
wa_apin_tblart_0_19 <- wa_apin_tblart_0_19 %>%
  mutate(art_sd = as.Date(art_sd))
art_after_dtg <- wa_apin_tblart_0_19 %>%
  filter(art_sd > dtg_sd)


#Select first ART regimen that doesn't contain DTG
#Do not count lines that don't include anchor drugs : these are just changes in NRTIs and not reflect DTG stop
anchors <- c("DTG", "BIC", "RAL","LPV/r", "ATV", "ATV/r", 
             "DRV", "DRV/r", "NFV", "IDV", "SQV", "TPV", "APV", "FPV", "PI_unspecified", 
             "EFV", "NVP", "RPV", "ETV", "ETVr", "DLV", "CPV","NNRTI_unspecified",
             "Maraviroc", "Enfurvirtide", "Vicriviroc" )


# Create a regex pattern to detect any anchor drug in the regimen
anchor_pattern <- str_c(anchors, collapse = "|")

# Filter to first non-DTG regimen per patient that contains at least one anchor drug
first_nondtg_regimen <- art_after_dtg %>%
  filter(
    !str_detect(arvtx_fixed, "DTG"),                        # Exclude regimens with DTG
    str_detect(arvtx_fixed, regex(anchor_pattern))          # Keep only if it includes an anchor drug
  ) %>%
  arrange(patient, art_sd) %>%
  group_by(patient) %>%
  slice(1) %>%
  ungroup()

#make art_sd the end_d : f/u ends when DTG is discontinued

final_non_dtg <- first_nondtg_regimen %>%
  select(patient, art_sd) %>%
  rename(end_d = art_sd) %>%
  mutate(
    end_d = as.Date(end_d),
    end = 1
  )

wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  left_join(final_non_dtg, by = "patient")

#Add death as another cause of end of f/u
#table with those who have end = NA and a death date in wa_apin_tblltfu;
# Filter patients with end = NA
no_end_patients <- wa_apin_dtg_0_19_full %>%
  filter(is.na(end)) %>%
  select(patient)
# Join with wa_apin_tblltfu to get death dates
died_without_end <- no_end_patients %>%
  inner_join(wa_apin_tblltfu %>% filter(!is.na(death_d)), by = "patient")
#Recode end_d and end variable
died_without_end <- died_without_end %>%
  select(patient, death_d) %>%
  rename(end_d = death_d) %>%
  mutate(
    end_d = as.Date(end_d),
    end = 2
  )
# Combine the two datasets
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  rows_patch(died_without_end, by = "patient")

wa_apin_dtg_0_19_full %>%
  count(end)

#Check for LTFU. Define as last clinical contact > 12 months;
# Filter patients with end = NA
patients_no_end <- wa_apin_dtg_0_19_full %>%
  filter(is.na(end)) %>%
  select(patient)

# Extract patient and date columns from each table (adjust date column names if needed)
art_dates <- wa_apin_tblart %>%
  select(patient, art_sd) %>%
  rename(date = art_sd)

cd4_dates <- wa_apin_tbllab_cd4 %>%
  select(patient, cd4_d) %>%
  rename(date = cd4_d)

rna_dates <- wa_apin_tbllab_rna %>%
  select(patient, rna_d) %>%
  rename(date = rna_d)

vis_dates <- wa_apin_tblvis %>%
  select(patient, vis_d) %>%
  rename(date = vis_d)

# Combine all dates into one table
all_dates <- bind_rows(art_dates, cd4_dates, rna_dates, vis_dates)

# Filter to patients with end = NA and get most recent date per patient
last_visits <- all_dates %>%
  semi_join(patients_no_end, by = "patient") %>%  # keep only relevant patients
  group_by(patient) %>%
  summarise(l_visit_d = max(date, na.rm = TRUE)) %>%
  ungroup()

# Add close_d and compute months difference
last_visits <- last_visits %>%
  left_join(wa_apin_tblbas %>% select(patient, close_d), by = "patient") %>%
  mutate(
    close_d = as.Date(close_d),
    l_visit_d = as.Date(l_visit_d),
    months_diff = interval(l_visit_d, close_d) %/% months(1)
  )

# Verif
any_negative <- any(last_visits$months_diff < 0)

if (any_negative) {
  message("Warning: There are negative months_diff values!")
} else {
  message("All months_diff values are zero or positive.")
}
negative_diff <- last_visits %>%
  filter(months_diff < 0)
#These are patients from Rahimamoosa,where close_d seems to be #wrong

#Code as LTFU those where months_diff >12
last_visits <- last_visits %>%
  mutate(end = if_else(months_diff > 12, 3, NA_integer_)) %>%
  rename(end_d = l_visit_d)
#Code as alive in care the others
last_visits <- last_visits %>%
  mutate(end = if_else(is.na(end), 4L, end))
last_visits <- last_visits %>%
  select(-close_d, -months_diff)
# Combine the two datasets
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  rows_patch(last_visits, by = "patient")

wa_apin_dtg_0_19_full %>%
  count(end)

#Median follow-up time
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    fu_months = interval(dtg_sd, end_d) / months(1),
    fu_months = round(fu_months, 1)  # optional: round to 1 decimal place
  )
#F/U < 6 months
dtg_fu_lt6 <- wa_apin_dtg_0_19_full %>%
  filter(!is.na(fu_months), fu_months < 6)
#Delete
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  filter(is.na(fu_months) | fu_months >= 6)
wa_apin_dtg_0_19_full %>%
  count(program)
wa_apin_dtg_0_19_full %>%
  count(end)


# Keep only wa_apin_dtg_0_19_full in your environment
#rm(list = setdiff(ls(), c("wa_apin_dtg_0_19_full", "wa_apin_tblart_clean_1")))
#This deletes all the objects, so don't forget to re import the primary tables! 
```

```{r message=FALSE, warning=FALSE, include=FALSE}
##Select with at least one VL measurement 

#Penser à re-importer les tbales de départ
# Either at baselibne +/- 6 months
# Or during follow-up
vl_selected <- wa_apin_tbllab_rna %>%
  left_join(wa_apin_dtg_0_19_full %>% select(patient, dtg_sd, end_d), by = "patient") %>%
  filter(
    !is.na(rna_d) & !is.na(dtg_sd) & !is.na(end_d) &
      rna_d >= (dtg_sd %m-% months(6)) &
      rna_d <= end_d
  ) %>%
  group_by(patient) %>%
  mutate(
    in_baseline_window = rna_d >= (dtg_sd %m-% months(6)) & rna_d <= (dtg_sd + days(14)),
    diff_days = if_else(in_baseline_window,
                        abs(as.numeric(difftime(rna_d, dtg_sd, units = "days"))),
                        NA_real_)
  ) %>%
  filter(in_baseline_window) %>%   # Keep only those in baseline window to find closest
  slice_min(diff_days, n = 1, with_ties = FALSE) %>%  # Pick the closest one, no ties
  mutate(baseline = 1) %>%
  ungroup()

# Then add back the other VLs (outside baseline window) with baseline = 0
vl_outside <- wa_apin_tbllab_rna %>%
  anti_join(vl_selected, by = c("patient", "rna_d")) %>%
  inner_join(wa_apin_dtg_0_19_full %>% select(patient, dtg_sd, end_d), by = "patient") %>%
  filter(
    !is.na(rna_d) & !is.na(dtg_sd) & !is.na(end_d) &
      rna_d >= (dtg_sd %m-% months(6)) &
      rna_d <= end_d
  ) %>%
  mutate(baseline = 0)

vl_selected_final <- bind_rows(vl_selected, vl_outside) %>%
  arrange(patient, rna_d)

#Check no more than one baseline value per patient
vl_selected_final %>%
  filter(baseline == 1) %>%
  count(patient) %>%
  filter(n > 1)

#Final VL table
wa_apin_vl_cleaned <- vl_selected_final %>%
  arrange(patient, rna_d) %>%  # Ensure order by patient and date
  group_by(patient) %>%
  mutate(
    # Get the baseline date if it exists (should be only one)
    baseline_rna_d = if (any(baseline == 1, na.rm = TRUE)) {
      rna_d[which(baseline == 1)[1]]
    } else {
      as.Date(NA)
    }
  ) %>%
  filter(
    # Keep all values on or after the baseline date, or all if there's no baseline
    is.na(baseline_rna_d) | rna_d >= baseline_rna_d
  ) %>%
  ungroup() %>%
  select(-baseline_rna_d)

#Keep in wa_apin_dtg_0_19_full, only patients with at least one VL value in vl_cleane
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  semi_join(wa_apin_vl_cleaned, by = "patient")

wa_apin_dtg_0_19_full %>%
  count(program)
wa_apin_dtg_0_19_full %>%
  count(end)


#rm(list = setdiff(ls(), c("wa_apin_dtg_0_19_full", "wa_apin_vl_cleaned", "wa_apin_tblart_clean_1")))
```


```{r message=FALSE, warning=FALSE, include=FALSE}
##ART regimen before DTG


# Keep only ART rows for children in wa_apin_dtg_0_19_full
tblart_children <- wa_apin_tblart_clean_1 %>%
  semi_join(wa_apin_dtg_0_19_full, by = "patient")
# Count distinct patients with at least one DTG date
num_patients <- tblart_children %>%
  summarise(n_patients = n_distinct(patient)) %>%
  pull(n_patients)


#Isolate art_sd just before dtg
art_before_dtg <- tblart_children %>%
  filter(art_sd < dtg_sd) %>%
  arrange(patient, desc(art_sd)) %>%
  group_by(patient) %>%
  slice(1) %>%
  ungroup()


# Step 1: Most recent ART line per patient with anchor drug
anchors <- c("DTG", "BIC", "RAL","LPV/r", "ATV", "ATV/r", 
             "DRV", "DRV/r", "NFV", "IDV", "SQV", "TPV", "APV", "FPV", "PI_unspecified", 
             "EFV", "NVP", "RPV", "ETV", "ETVr", "DLV", "CPV","NNRTI_unspecified",
             "Maraviroc", "Enfurvirtide", "Vicriviroc" )
anchor_pattern <- str_c(anchors, collapse = "|")
anchor_lines <- art_before_dtg %>%
  filter(str_detect(arvtx_fixed, regex(anchor_pattern))) %>%
  arrange(patient, desc(art_sd)) %>%
  group_by(patient) %>%
  slice(1) %>%
  ungroup()
# Step 2: Patients with no anchor drug lines
patients_with_anchor <- unique(anchor_lines$patient)

fallback_lines <- art_before_dtg %>%
  filter(!patient %in% patients_with_anchor) %>%
  arrange(patient, desc(art_sd)) %>%
  group_by(patient) %>%
  slice(1) %>%
  ungroup()

# Step 3: Combine both sets
prev_dtg <- bind_rows(anchor_lines, fallback_lines)

#If ART_ED is missing, assume it's dtg_sd
prev_dtg  <- prev_dtg  %>%
  mutate(
    art_ed = coalesce(art_ed, dtg_sd)  # if art_ed is NA, use dtg_sd
  )

#Define ART_class 
#Define treatment class
nrtis   <- c("3TC", "ABC", "AZT", "FTC", "TDF", "TAF", "ddI", "d4T", "NRTI_unspecified", "ddC")
pis     <- c("LPV/r", "ATV", "ATV/r", "DRV", "DRV/r", "NFV", "IDV", "SQV", "TPV", "APV", "FPV", "PI_unspecified")
instis  <- c("DTG", "BIC", "RAL")
nnrtis  <- c("EFV", "NVP", "RPV", "ETV", "ETVr", "DLV", "CPV","NNRTI_unspecified")
entry_fusion <- c("Maraviroc", "Enfurvirtide", "Vicriviroc")
boosters <- c("RTV", "Cobicistat")

prev_dtg <- prev_dtg %>%
  mutate(
    has_pi     = str_detect(arvtx_fixed, str_c(pis, collapse = "|")),
    has_nnrt   = str_detect(arvtx_fixed, str_c(nnrtis, collapse = "|")),
    has_insti  = str_detect(arvtx_fixed, str_c(instis, collapse = "|")),
    has_entry  = str_detect(arvtx_fixed, str_c(entry_fusion, collapse = "|")),
    
    art_class = case_when(
      has_pi & has_insti   ~ "PI+INSTI",
      has_pi & has_nnrt    ~ "PI+NNRTI",
      has_insti & has_nnrt ~ "INSTI+NNRTI",
      has_pi & has_entry   ~ "PI+ENTRY",
      has_insti & has_entry ~ "INSTI+ENTRY",
      has_pi     ~ "PI",
      has_insti  ~ "INSTI",
      has_nnrt   ~ "NNRTI",
      has_entry  ~ "ENTRY/FUSION",
      TRUE       ~ "NRTIs"
    )
  )

#If classified as a suspect ART regimen then code as unknown
prev_dtg <- prev_dtg %>%
  mutate(
    art_class = if_else(regimen_classification %in% c("Ambiguous", "Likely Data Error"), "Unknown", art_class)
  )

#Rename ART_class as "prev_art_class"
#Rename art_ed as "prev_art_end_d"

prev_dtg <- prev_dtg %>%
  rename(
    prev_art_class   = art_class,
    prev_art_end_d   = art_ed,
    prev_art_regimen = arvtx_fixed
  )

#Keep a table with just these variables and patient and add to full_dtg table
# Step 1: Keep only relevant variables from prev_dtg
prev_dtg_trimmed <- prev_dtg %>%
  select(patient, prev_art_class, prev_art_end_d, prev_art_regimen)

# Step 2: Join into full_dtg table
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  left_join(prev_dtg_trimmed, by = "patient")

#Calculate time between prev_art_ed and dtg_sd
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    time_from_prev_end_to_dtg_months = time_length(interval(prev_art_end_d, dtg_sd), unit = "months")
  )

wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    prev_art_class_vf = case_when(
      is.na(prev_art_class) ~ "naive",
      time_from_prev_end_to_dtg_months >= 6 ~ "reinitiator",
      TRUE ~ prev_art_class  # for everyone else
    )
  )

#Create an indicator variable for tt interruption < 6 months prior to DTG initiation
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    tt_interruption = if_else(
      time_from_prev_end_to_dtg_months >= 1 & time_from_prev_end_to_dtg_months < 6,
      1, 0, missing = 0
    )
  )

# Now count previous first_line
wa_apin_dtg_0_19_full %>%
  count(prev_art_class_vf, name = "n") %>%
  arrange(desc(n))

#NRTI switch
# Create indicator for NRTI switch
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    curr_nrtis = strsplit(arvtx_fixed, "\\+") %>% 
      lapply(function(drugs) drugs[drugs %in% nrtis]),
    
    prev_nrtis = strsplit(prev_art_regimen, "\\+") %>% 
      lapply(function(drugs) drugs[drugs %in% nrtis]),
    
    nrti_switch = mapply(function(curr, prev, cls) {
      if (cls %in% c("naive", "reinitiator") || is.null(prev) || length(prev) == 0) {
        return(0)
      }
      as.integer(any(!curr %in% prev))
    }, curr_nrtis, prev_nrtis, prev_art_class_vf)
  ) %>%
  select(-curr_nrtis, -prev_nrtis)

# count nrti switches
wa_apin_dtg_0_19_full %>%
  count(nrti_switch, name = "n") %>%
  arrange(desc(n))

#rm(list = setdiff(ls(), c("wa_apin_dtg_0_19_full", "wa_apin_vl_cleaned", "wa_apin_tblart_clean_1")))
```

```{r message=FALSE, warning=FALSE, include=FALSE}
##Code pour la charge virale

wa_apin_vl_cleaned <- wa_apin_vl_cleaned %>%
  mutate(
    vl_class = case_when(
      rna_v < 200 ~ 1,
      rna_v >= 200 & rna_v < 1000 ~ 2,
      rna_v >= 1000 ~ 3,
      TRUE ~ NA_integer_  # in case rna_v is missing
    )
  )
wa_apin_vl_cleaned %>%
  count( vl_class, name = "n") %>%
  arrange(desc(n))

 # Step 1: Filter baseline viral loads and select needed columns
   vl_baseline <- wa_apin_vl_cleaned %>%
   filter(baseline == 1) %>%
  select(patient, baseline_vl = vl_class)

 # Step 2: Left join with wa_apin_dtg_0_19_full
  wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
    left_join(vl_baseline, by = "patient")
  
wa_apin_dtg_0_19_full %>%
    count( baseline_vl, name = "n") %>%
    arrange(desc(n))
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(baseline_vl = replace_na(baseline_vl, 9))

#Charge virale à 6 mois, +/- 3 mois: 
         
vl_6 <- wa_apin_vl_cleaned %>%
  mutate(
    target_date = dtg_sd %m+% months(6),  # 6 months after start
    diff_days = abs(as.numeric(difftime(rna_d, target_date, units = "days")))
  ) %>%
  filter(
    rna_d >= (target_date - months(3)) &
      rna_d <= (target_date + months(3))
  ) %>%
  group_by(patient) %>%
  slice_min(order_by = diff_days, with_ties = FALSE) %>%  # closest to target date
  ungroup() %>%
  select(patient, vl_6 = rna_v)  # rename as required

#Charge virale à 12 mois, +/- 6 mois:          
vl_12 <- wa_apin_vl_cleaned %>%
  mutate(
    target_date = dtg_sd %m+% months(12),  # 12 mois après le début
    diff_days = abs(as.numeric(difftime(rna_d, target_date, units = "days")))
  ) %>%
  filter(
    rna_d >= (target_date - months(6)) &  # fenêtre -6 mois
      rna_d <= (target_date + months(6))  # fenêtre +6 mois
  ) %>%
  group_by(patient) %>%
  slice_min(order_by = diff_days, with_ties = FALSE) %>%  # mesure la plus proche
  ungroup() %>%
  select(patient, vl_12 = rna_v) 

#Charge virale à 24 mois, +/- 6 mois: 
vl_24 <- wa_apin_vl_cleaned %>%
  mutate(
    target_date = dtg_sd %m+% months(24),  # 24 mois après le début
    diff_days = abs(as.numeric(difftime(rna_d, target_date, units = "days")))
  ) %>%
  filter(
    rna_d >= (target_date - months(6)) &   # fenêtre -6 mois
      rna_d <= (target_date + months(6))   # fenêtre +6 mois
  ) %>%
  group_by(patient) %>%
  slice_min(order_by = diff_days, with_ties = FALSE) %>%  # mesure la plus proche
  ungroup() %>%
  select(patient, vl_24 = rna_v)


#Merge back into dtg full table
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  left_join(vl_6, by = "patient") %>%
  left_join(vl_12, by = "patient") %>%
  left_join(vl_24, by = "patient")

#Code les classes de charge virale
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    vl_6_class = case_when(
      !is.na(vl_6) & vl_6 < 200 ~ 1,
      !is.na(vl_6) & vl_6 >= 200 & vl_6 < 1000 ~ 2,
      !is.na(vl_6) & vl_6 >= 1000 ~ 3,
      is.na(vl_6) ~ 9
    ),
    vl_12_class = case_when(
      !is.na(vl_12) & vl_12 < 200 ~ 1,
      !is.na(vl_12) & vl_12 >= 200 & vl_12 < 1000 ~ 2,
      !is.na(vl_12) & vl_12 >= 1000 ~ 3,
      is.na(vl_12) & fu_months >= 12 ~ 9,
      is.na(vl_12) ~ 99
    ),
    vl_24_class = case_when(
      !is.na(vl_24) & vl_24 < 200 ~ 1,
      !is.na(vl_24) & vl_24 >= 200 & vl_24 < 1000 ~ 2,
      !is.na(vl_24) & vl_24 >= 1000 ~ 3,
      is.na(vl_24) & fu_months >= 24 ~ 9,
      is.na(vl_24) ~ 99
    )
  )
```

```{r}
#write.csv2(wa_apin_dtg_0_19_full, "wa_apin_dtg_0_19_full_managT.csv")
#write.csv2(wa_apin_vl_cleaned, "wa_apin_vl_cleaned_managT.csv")
#write.csv2(wa_apin_tblart_clean_1, "wa_apin_tblart_clean_1_managT.csv")
```

\newpage
```{r include=FALSE}
###La variable sex pose problème : refaire le merge: 
# Check both datasets contain 'patient' and 'sex' variables
stopifnot("patient" %in% names(wa_apin_dtg_0_19_full), "sex" %in% names(wa_apin_tblbas))
```

```{r include=FALSE}
# Step 0_1: Select patient and sex from wa_apin_tblbas
sex_lookup <- wa_apin_tblbas %>%
  select(patient, sex) %>%
  filter(!is.na(sex))
```

```{r include=FALSE}
# Step 0_2: Replace sex in wa_apin_dtg_0_19_full by joining with lookup
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  select(-sex) %>%  # drop existing (possibly broken) sex
  left_join(sex_lookup, by = "patient")  # merge correct sex in
```

```{r include=FALSE}
# --- Step 1: Prepare derived variables ---
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    age = as.numeric(difftime(dtg_sd, birth_d, units = "days")) / 365.25,
    age_cat = cut(age, breaks = c(-Inf, 5, 10, 15, 20), 
                  labels = c("<5", "5-9", "10-14", "15-19"), right = FALSE),
    age_art_init = as.numeric(difftime(recart_d, birth_d, units = "days")) / 365.25,
    art_duration_before_dtg = as.numeric(difftime(dtg_sd, recart_d, units = "days")) / 365.25,
    sex = factor(sex, levels = c(1, 2), labels = c("Male", "FeMale")),
    baseline_vl_label = factor(baseline_vl, levels = c(1, 2, 3, 9), 
                         labels = c("Undetectable < 200", "Low level viremia [200-1000[", ">=1000", "Unknown")),
)

median(wa_apin_dtg_0_19_full$age)
quantile(wa_apin_dtg_0_19_full$age, probs = c(0.25, 0.75))

# --- Step 2: Define variables ---
cat_vars <- c("sex", "age_cat", "prev_art_class_vf", 
              "baseline_vl", "nrti_switch")

cont_vars <- c("age", "age_art_init", "art_duration_before_dtg", "fu_months")

all_vars <- c(cat_vars, cont_vars)


# --- Step 3: Define variable labels ---
var_labels <- c(
  sex = "Sex",
  age_cat = "Age category (years)",
  age = "Age (years)",
  age_art_init = "Age at ART initiation (years)",
  art_duration_before_dtg = "Duration on ART before DTG (months)",
  prev_art_class_vf = "Previous ART class",
  baseline_vl = "Baseline viral load",
  nrti_switch = "NRTI switch at DTG initiation",
  fu_months = "Follow-up on DTG (months)"
)

# --- Step 4: Create TableOne with Overall column ---
table1 <- CreateTableOne(
  vars = all_vars,
  strata = "program",
  data = wa_apin_dtg_0_19_full,
  factorVars = cat_vars,
  includeNA = TRUE,
  addOverall = TRUE
)
```

\newpage
\section{Results}
\subsubsection{Baseline characteristics of study population}
```{r}
tbl_describ <- wa_apin_dtg_0_19_full %>%
  mutate(overall = "OVERALL")
tbl0 <- tbl_describ %>%
  #filter(program %in% c("CEPREF",  "CHUC",    "CHUY",   "CIRBA",    "CNHU")) %>%
  select(overall, all_of(cat_vars), all_of(cont_vars)) %>%
  tbl_summary(
    by = overall,
    type = list(all_of(cont_vars) ~ "continuous", all_of(cat_vars) ~ "categorical"),
    statistic = list(
      all_of(cont_vars) ~ "{median} [{p25}; {p75}]",
      all_of(cat_vars) ~ "{n} ({p}%)"
    ),
    missing = "ifany",
    label = list(
      sex ~ "Sex",
      age_cat ~ "Age category (years)",
      age ~ "Age (years)",
      age_art_init ~ "Age at ART initiation (years)",
      art_duration_before_dtg ~ "Duration on ART before DTG (months)",
      prev_art_class_vf ~ "Previous ART class",
      baseline_vl ~ "Baseline viral load",
      nrti_switch ~ "NRTI switch at DTG initiation",
      fu_months ~ "Follow-up on DTG (months)"
    )
  ) %>%
  bold_labels()

tbl0_kable1 <- tbl0 %>%
  as_kable(format = "latex", booktabs = TRUE, linesep = "\\addlinespace") %>%
  kable_styling(
    latex_options = c("hold_position", "striped", "repeat_header"),
    font_size = 12
  )

tbl0_kable1
#write.xlsx(tbl0, "dtg_characteristics_by_region.xlsx")
```

\newpage
\begin{landscape}
\subsubsection{Baseline characteristics of study population by program (1)}
```{r}
tbl1 <- wa_apin_dtg_0_19_full %>%
  filter(program %in% c("CEPREF",  "CHUC",    "CHUY",   "CIRBA",    "CNHU")) %>%
  select(program, all_of(cat_vars), all_of(cont_vars)) %>%
  tbl_summary(
    by = program,
    type = list(all_of(cont_vars) ~ "continuous", all_of(cat_vars) ~ "categorical"),
    statistic = list(
      all_of(cont_vars) ~ "{median} [{p25}; {p75}]",
      all_of(cat_vars) ~ "{n} ({p}%)"
    ),
    missing = "ifany",
    label = list(
      sex ~ "Sex",
      age_cat ~ "Age category (years)",
      age ~ "Age (years)",
      age_art_init ~ "Age at ART initiation (years)",
      art_duration_before_dtg ~ "Duration on ART before DTG (months)",
      prev_art_class_vf ~ "Previous ART class",
      baseline_vl ~ "Baseline viral load",
      nrti_switch ~ "NRTI switch at DTG initiation",
      fu_months ~ "Follow-up on DTG (months)"
    )
  ) %>%
  bold_labels()

tbl1_kable1 <- tbl1 %>%
  as_kable(format = "latex", booktabs = TRUE, linesep = "\\addlinespace") %>%
  kable_styling(
    latex_options = c("hold_position", "striped", "repeat_header"),
    font_size = 8
  )

tbl1_kable1
#write.xlsx(tbl1, "dtg_characteristics_by_region.xlsx")
```
\end{landscape}

\newpage
\begin{landscape}
\subsubsection{Baseline characteristics of study population by program (2)}
```{r}
tbl2 <- wa_apin_dtg_0_19_full %>%
  filter(program %in% c("GABRIEL", "KBTH",  "NIMR", "TOKOIN","YALGADO")) %>%
  select(program, all_of(cat_vars), all_of(cont_vars)) %>%
  tbl_summary(
    by = program,
    type = list(all_of(cont_vars) ~ "continuous", all_of(cat_vars) ~ "categorical"),
    statistic = list(
      all_of(cont_vars) ~ "{median} [{p25}; {p75}]",
      all_of(cat_vars) ~ "{n} ({p}%)"
    ),
    missing = "ifany",
    label = list(
      sex ~ "Sex",
      age_cat ~ "Age category (years)",
      age ~ "Age (years)",
      age_art_init ~ "Age at ART initiation (years)",
      art_duration_before_dtg ~ "Duration on ART before DTG (months)",
      prev_art_class_vf ~ "Previous ART class",
      baseline_vl ~ "Baseline viral load",
      nrti_switch ~ "NRTI switch at DTG initiation",
      fu_months ~ "Follow-up on DTG (months)"
    )
  ) %>%
  bold_labels()

tbl2_kable1 <- tbl2 %>%
  as_kable(format = "latex", booktabs = TRUE, linesep = "\\addlinespace") %>%
  kable_styling(
    latex_options = c("hold_position", "striped", "repeat_header"),
    font_size = 8
  )

tbl2_kable1
#write.xlsx(tbl2, "dtg_characteristics_by_region.xlsx")
```
\end{landscape}

\newpage
\begin{landscape}
\subsubsection{Baseline characteristics of study population by program (3)}
```{r}
tbl3 <- wa_apin_dtg_0_19_full %>%
  filter(program %in% c("ABEOKUTA", "AKURE",  "JOS", "MAKURDI","UCH")) %>%
  select(program, all_of(cat_vars), all_of(cont_vars)) %>%
  tbl_summary(
    by = program,
    type = list(all_of(cont_vars) ~ "continuous", all_of(cat_vars) ~ "categorical"),
    statistic = list(
      all_of(cont_vars) ~ "{median} [{p25}; {p75}]",
      all_of(cat_vars) ~ "{n} ({p}%)"
    ),
    missing = "ifany",
    label = list(
      sex ~ "Sex",
      age_cat ~ "Age category (years)",
      age ~ "Age (years)",
      age_art_init ~ "Age at ART initiation (years)",
      art_duration_before_dtg ~ "Duration on ART before DTG (months)",
      prev_art_class_vf ~ "Previous ART class",
      baseline_vl ~ "Baseline viral load",
      nrti_switch ~ "NRTI switch at DTG initiation",
      fu_months ~ "Follow-up on DTG (months)"
    )
  ) %>%
  bold_labels()

tbl3_kable1 <- tbl3 %>%
  as_kable(format = "latex", booktabs = TRUE, linesep = "\\addlinespace") %>%
  kable_styling(
    latex_options = c("hold_position", "striped", "repeat_header"),
    font_size = 8
  )

tbl3_kable1
#write.xlsx(tbl2, "dtg_characteristics_by_region.xlsx")
```

```{r eval=FALSE, include=FALSE}
tbl4 <- wa_apin_dtg_0_19_full %>%
  select(program, all_of(cat_vars), all_of(cont_vars)) %>%
  tbl_summary(
    type = list(all_of(cont_vars) ~ "continuous", all_of(cat_vars) ~ "categorical"),
    statistic = list(
      all_of(cont_vars) ~ "{median} [{p25}; {p75}]",
      all_of(cat_vars) ~ "{n} ({p}%)"
    ),
    missing = "ifany",
    label = list(
      sex ~ "Sex",
      age_cat ~ "Age category (years)",
      age ~ "Age (years)",
      age_art_init ~ "Age at ART initiation (years)",
      art_duration_before_dtg ~ "Duration on ART before DTG (months)",
      prev_art_class_vf ~ "Previous ART class",
      baseline_vl ~ "Baseline viral load",
      nrti_switch ~ "NRTI switch at DTG initiation",
      fu_months ~ "Follow-up on DTG (months)"
    )
  ) %>%
  #add_overall(last = TRUE) %>%
  #add_p(
  #  test.args = all_categorical() ~ list(simulate.p.value = TRUE) # << clé ici
  #) 
#%>%  bold_labels()

tbl4_kable1 <- tbl4 %>%
  as_kable(format = "latex", booktabs = TRUE, linesep = "\\addlinespace") %>%
  kable_styling(
    latex_options = c("hold_position", "striped", "repeat_header"),
    font_size = 6
  )

tbl4_kable1
#write.xlsx(tbl2, "dtg_characteristics_by_region.xlsx")
```
\end{landscape}


```{r include=FALSE}
### Données de suivi 

# --- Step 1: Prepare derived variables ---
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    follow_up_months = as.numeric(difftime(end_d, dtg_sd, units = "days")) / 30.44,
    end_reason = factor(end, levels = c(1, 2, 3), 
                        labels = c("DTG Discontinuation", "Death", "LTFU")),
    vl_6_class = na_if(vl_6_class, 99),
    vl_12_class = na_if(vl_12_class, 99),
    vl_24_class = na_if(vl_24_class, 99)
  )

# --- Step 2: TableOne for follow-up time and end reason by region ---
followup_vars <- c("follow_up_months", "end_reason")

table_followup <- CreateTableOne(
  vars = followup_vars,
  strata = "program",
  data = wa_apin_dtg_0_19_full,
  factorVars = "end_reason",
  addOverall = TRUE,
  includeNA = TRUE
)

# Convert to data.frame
followup_df <- print(
  table_followup,
  printToggle = FALSE,
  quote = FALSE,
  noSpaces = TRUE,
  showAllLevels = TRUE,
  test = TRUE
) %>%
  as.data.frame() %>%
  rownames_to_column(var = "Variable")

followup_summary <- wa_apin_dtg_0_19_full %>%
  group_by(program) %>%
  summarise(
    Median = round(median(follow_up_months, na.rm = TRUE), 1),
    Q1 = round(quantile(follow_up_months, 0.25, na.rm = TRUE), 1),
    Q3 = round(quantile(follow_up_months, 0.75, na.rm = TRUE), 1)
  ) %>%
  mutate(
    Value = paste0(Median, " (", Q1, "–", Q3, ")"),
    Variable = "Follow-up time (months)"
  ) %>%
  select(Variable, program, Value) %>%
  tidyr::pivot_wider(names_from = program, values_from = Value)

# Combine with followup_df
followup_df <- bind_rows(followup_summary, followup_df)

# --- Step 3: VL summary function with totals by region and timepoint ---

vl_labels <- c(
  "1" = "Undetectable (<200)", 
  "2" = "Low-level viremia", 
  "3" = ">= 1000 copies", 
  "9" = "Unknown"
)

# Custom function to get count + percentage by region
summarize_vl <- function(df, var, time_label) {
  df <- df %>% filter(!is.na(.data[[var]]))
  counts <- df %>%
    group_by(program, !!sym(var)) %>%
    tally() %>%
    group_by(program) %>%
    mutate(
      Percent = round(100 * n / sum(n), 1),
      Category = vl_labels[as.character(!!sym(var))]
    ) %>%
    ungroup()
  
  # Add totals per region
  totals <- df %>%
    group_by(program) %>%
    tally(name = "n") %>%
    mutate(
      Percent = NA,
      Category = "Total included",
      !!var := NA
    )
  
  bind_rows(counts, totals) %>%
    mutate(Timepoint = time_label) %>%
    select(Timepoint, program, Category, n, Percent)
}

vl6  <- summarize_vl(wa_apin_dtg_0_19_full, "vl_6_class", "6 months")
vl12 <- summarize_vl(wa_apin_dtg_0_19_full, "vl_12_class", "12 months")
vl24 <- summarize_vl(wa_apin_dtg_0_19_full, "vl_24_class", "24 months")

# Combine all
vl_all <- bind_rows(vl6, vl12, vl24)

# Pivot for display (wide format: rows = Category, columns = regions)
vl_clean <- vl_all %>%
  mutate(
    Region = as.character(program),
    Value = ifelse(is.na(Percent), as.character(n), paste0(n, " (", Percent, "%)"))
  ) %>%
  select(Timepoint, Category, Region, Value) %>%
  tidyr::pivot_wider(
    names_from = Region,
    values_from = Value,
    values_fill = ""
  ) %>%
  arrange(Timepoint, Category)

vl_clean <- vl_clean %>%
  mutate(
    Timepoint = factor(Timepoint, levels = c("6 months", "12 months", "24 months")),
    Category = factor(Category, levels = c(
      "Total included", 
      "Undetectable (<200)", 
      "Low-level viremia", 
      ">= 1000 copies", 
      "Unknown"
    ))
  ) %>%
  arrange(Timepoint, Category)

# --- Step 4: Export to Word ---

doc <- read_docx() %>%
  body_add_par("Follow-up Characteristics by Region", style = "heading 1")

# Add follow-up time and end reason table
ft1 <- flextable(followup_df) %>% autofit()
doc <- doc %>%
  body_add_par("Follow-up time and end of follow-up reason", style = "heading 2") %>%
  body_add_flextable(ft1)

# Add viral load summary
ft2 <- flextable(vl_clean) %>% autofit()
doc <- doc %>%
  body_add_par("Viral load categories at 6, 12, 24 months", style = "heading 2") %>%
  body_add_flextable(ft2)

# Save
print(doc, target = "followup_summary.docx")



median(wa_apin_dtg_0_19_full$follow_up_months)
quantile(wa_apin_dtg_0_19_full$follow_up_months, probs = c(0.25, 0.75))
```

```{r include=FALSE}

### Describe DTG initiation practices
# --- Step 1: Recode into DTG regimen classes ---

wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    dtg_class = case_when(
      arvtx_fixed == "3TC+DTG+TDF" ~ "3TC+DTG+TDF",
      arvtx_fixed == "3TC+ABC+DTG" ~ "3TC+ABC+DTG",
      arvtx_fixed == "3TC+AZT+DTG" ~ "3TC+AZT+DTG",
      str_detect(arvtx_fixed, "DTG") & str_detect(arvtx_fixed, "DRV") & str_detect(arvtx_fixed, "RTV") ~ "DTG+DRV+RTV (any combo)",
      TRUE ~ "Unspecified"
    ),
    dtg_class = factor(dtg_class, levels = c(
      "3TC+DTG+TDF",
      "3TC+ABC+DTG",
      "3TC+AZT+DTG",
      "DTG+DRV+RTV (any combo)",
      "Unspecified"
    ))
  )

# --- Step 2: Create TableOne summary by region ---

class_table <- CreateTableOne(
  vars = "dtg_class",
  strata = "program",
  data = wa_apin_dtg_0_19_full,
  factorVars = "dtg_class",
  addOverall = TRUE,
  includeNA = TRUE
)

# --- Step 3: Format the output table ---

class_df <- print(
  class_table,
  printToggle = FALSE,
  quote = FALSE,
  noSpaces = TRUE,
  showAllLevels = TRUE,
  test = TRUE
) %>%
  as.data.frame() %>%
  rownames_to_column(var = "DTG Regimen Class")

# --- Step 4: Create flextable and export to Word ---

ft_class <- flextable(class_df) %>%
  autofit() %>%
  theme_booktabs()

doc <- read_docx() %>%
  body_add_par("DTG Regimen  by Region", style = "heading 1") %>%
  body_add_flextable(ft_class)

# Save Word file
print(doc, target = "dtg_regimen_by_region.docx")
```

```{r}
### Description of NRTI switches where possible

# Step 1: Define NRTIs
nrtis <- c("3TC", "ABC", "AZT", "FTC", "TDF", "TAF", "ddI", "d4T", "NRTI_unspecified", "ddC")
regex_nrtis <- str_c(nrtis, collapse = "|")

# Step 2: Filter to switchers and extract NRTIs
nrtis_switched <- wa_apin_dtg_0_19_full %>%
  filter(nrti_switch == 1) %>%
  mutate(
    prev_nrtis = str_extract_all(str_to_upper(prev_art_regimen), regex_nrtis),
    current_nrtis = str_extract_all(str_to_upper(arvtx_fixed), regex_nrtis)
  )

# Step 3: Collapse into NRTI backbones (sorted combinations)
combine_nrtis <- function(x) {
  if (length(x) == 0 || all(is.na(x))) return(NA)
  x <- sort(trimws(x))
  paste(x, collapse = "+")
}

nrtis_switched <- nrtis_switched %>%
  rowwise() %>%
  mutate(
    prev_backbone = combine_nrtis(prev_nrtis),
    current_backbone = combine_nrtis(current_nrtis),
    backbone_switch = paste(prev_backbone, "→", current_backbone),
    n_prev = ifelse(is.na(prev_backbone), 0, str_count(prev_backbone, "\\+") + 1),
    n_current = ifelse(is.na(current_backbone), 0, str_count(current_backbone, "\\+") + 1),
    valid_combo = n_prev >= 2 & n_current >= 2
  ) %>%
  ungroup()

# Step 4: Assign backbone switch or "Other switches"
nrtis_switched <- nrtis_switched %>%
  mutate(
    backbone_switch_grouped = ifelse(valid_combo, backbone_switch, "Other switches")
  )

# Step 5: Count switch types by region
switch_counts <- nrtis_switched %>%
  filter(!is.na(backbone_switch_grouped)) %>%
  count(program, backbone_switch_grouped, name = "n")

# Step 6: Add overall column
overall_counts <- switch_counts %>%
  group_by(backbone_switch_grouped) %>%
  summarise(n = sum(n), .groups = "drop") %>%
  mutate(program = "Overall")

# Combine and pivot
switch_all <- bind_rows(switch_counts, overall_counts)

switch_table <- switch_all %>%
  pivot_wider(names_from = program, values_from = n, values_fill = 0) %>%
  mutate(Overall = rowSums(across(where(is.numeric)))) %>%
  arrange(if_else(backbone_switch_grouped == "Other switches", 1, 0), desc(Overall))

# Step 7: Export to Word
ft <- flextable(switch_table) %>%
  autofit() %>%
  theme_booktabs()

doc <- read_docx() %>%
  body_add_par("NRTI Backbone Switch Patterns by Region", style = "heading 1") %>%
  body_add_flextable(ft)

print(doc, target = "nrtis_backbone_switch_by_region_grouped.docx")

write.csv(wa_apin_dtg_0_19_full, "wa_apin_dtg_0_19_full.csv", row.names = FALSE)
```

\begin{landscape}
\subsection{Sankey diagram}
```{r message=FALSE, warning=FALSE, include=FALSE}
# labels of VL
unique(wa_apin_dtg_0_19_full$baseline_vl)
unique(wa_apin_dtg_0_19_full$vl_6_class)
unique(wa_apin_dtg_0_19_full$vl_12_class)
unique(wa_apin_dtg_0_19_full$vl_24_class)

vl_labels <- c(
  `1` = "Undetectable (<200)",
  `2` = "Low-level viremia",
  `3` = ">= 1000 copies",
  `9` = "Unknown",
  `99` = "Right-censored"
)

wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    baseline_vl_label = factor(baseline_vl, levels = names(vl_labels), labels = vl_labels),
    vl_6_label = factor(vl_6_class, levels = names(vl_labels), labels = vl_labels),
    vl_12_label = factor(vl_12_class, levels = names(vl_labels), labels = vl_labels),
    vl_24_label = factor(vl_24_class, levels = names(vl_labels), labels = vl_labels)
  )
levels(wa_apin_dtg_0_19_full$vl_6_label)

#Create Pairwise Transition Tables
#From Baseline to 6 Months
trans_0_6 <- wa_apin_dtg_0_19_full %>%
  filter(!is.na(baseline_vl_label) & !is.na(vl_6_label)) %>%
  count(source = baseline_vl_label, target = vl_6_label)
#6 to 12 Months
trans_6_12 <- wa_apin_dtg_0_19_full %>%
  filter(!is.na(vl_6_label) & !is.na(vl_12_label)) %>%
  count(source = vl_6_label, target = vl_12_label)
#12 to 24 Months
trans_12_24 <- wa_apin_dtg_0_19_full %>%
  filter(!is.na(vl_12_label) & !is.na(vl_24_label)) %>%
  count(source = vl_12_label, target = vl_24_label)

#Add Stage Info and Combine All Transitions (for Sankey)
trans_0_6$stage <- "0-6"
trans_6_12$stage <- "6-12"
trans_12_24$stage <- "12-24"

trans_all <- bind_rows(
  trans_0_6,
  trans_6_12,
  trans_12_24
)

#Add Time to Node Names
#Sankey tools often require unique node names, so you can modify the source/target like this:

trans_all <- trans_all %>%
  mutate(
    source_node = paste0(source, " (", gsub("-.*", "", stage), "m)"),
    target_node = paste0(target, " (", gsub(".*-", "", stage), "m)")
  )




##########################################################################################
#Other option : prepare data for SankeyMATIC (https://sankeymatic.com/build/)
#Paste the lines into the “Build a Sankey Diagram” box from the sankey_input.txt built below.

# Step: Create SankeyMATIC strings
sankey_input_0_6_12_24 <- trans_all %>%
  mutate(
    source_node = paste0(source, " (", gsub("-.*", "", stage), "m)"),
    target_node = paste0(target, " (", gsub(".*-", "", stage), "m)"),
    sankey_line = paste0(source_node, " [", n, "] ", target_node)
  ) %>%
  pull(sankey_line)
#Save text file
writeLines(sankey_input_0_6_12_24, "sankey_input_0_6_12_24.txt")
```

\subsubsection{Sankey Diagram of Viral Load Transitions (M0 → M6 → M12 → M24)}
At baseline, most children and adolescents living with HIV (CALHIV) had undetectable viral load (VL, <200 copies/mL). Among them, the majority remained suppressed at 6 months, while a small number transitioned to low-level viremia (LLV, 200–999 copies/mL) or virological failure (VF, >= 1000 copies/mL), and some had missing results. Patients with LLV or VF at baseline showed variable outcomes, with some achieving suppression and others remaining viremic or missing data. Those with unknown baseline VL partially recovered, with many achieving suppression by 6 months.

Between 6 and 24 months, viral suppression remained largely stable. Most patients initially suppressed maintained undetectable VL, while some with LLV, VF, or unknown VL continued to improve. LLV trajectories were heterogeneous, with some improving and others progressing to VF. Overall, these results demonstrate sustained viral control under dolutegravir-based therapy, with continued improvement even among patients with initially high or unknown VL.
```{r fig.align='center', out.width='100%'}
knitr::include_graphics("C:/Users/Emile/Desktop/IeDEA/projet réponse virologique/TRV pwada vEmile Sept25/news file TRV pwada Oct25/sankeymatic_0_6_12_24.png") 
```
\end{landscape}

```{r}
#Re-order text in Sankey input to have the categories in the order you want
#Add following  code for colors
# :>= 1000 copies (0m) #FF0000 << >>
# :>= 1000 copies (6m) #FF0000  >>
# :>= 1000 copies (12m) #FF0000  >>
# :>= 1000 copies (24m) #FF0000  >>

# :Undetectable (<200) (0m) #1b9e77 >>
# :Undetectable (<200) (6m) #1b9e77 >>
# :Undetectable (<200) (12m) #1b9e77 >>
# :Undetectable (<200) (24m) #1b9e77 >>

# :Low-level viremia (0m) #FFD700 >>
# :Low-level viremia (6m) #FFD700 >>
# :Low-level viremia (12m) #FFD700 >>
# :Low-level viremia (24m) #FFD700 >>

# :Right-censored (12m) #888888 << >>
# :Right-censored (24m) #888888 << >>

# :Unknown (0m) #ADD8E6 << >>
# :Unknown (6m) #ADD8E6 << >>
# :Unknown (12m) #ADD8E6 << >>
# :Unknown (24m) #ADD8E6 << >>

###########################################################################
#Prepare second table excluding the 6-month timepoint
###########################################################################
# Ensure label variables are factors with full label levels
wa_apin_dtg_0_19_full <- wa_apin_dtg_0_19_full %>%
  mutate(
    baseline_vl_label = factor(baseline_vl, levels = names(vl_labels), labels = vl_labels),
    vl_12_label = factor(vl_12_class, levels = names(vl_labels), labels = vl_labels),
    vl_24_label = factor(vl_24_class, levels = names(vl_labels), labels = vl_labels)
  )

# Create all combinations of source and target labels
label_levels <- factor(vl_labels, levels = vl_labels)

# 0 → 12 months transition
trans_0_12 <- wa_apin_dtg_0_19_full %>%
  filter(!is.na(baseline_vl_label) & !is.na(vl_12_label)) %>%
  count(source = baseline_vl_label, target = vl_12_label) %>%
  complete(source = label_levels, target = label_levels, fill = list(n = 0)) %>%
  mutate(stage = "0-12")

# 12 → 24 months transition
trans_12_24 <- wa_apin_dtg_0_19_full %>%
  filter(!is.na(vl_12_label) & !is.na(vl_24_label)) %>%
  count(source = vl_12_label, target = vl_24_label) %>%
  complete(source = label_levels, target = label_levels, fill = list(n = 0)) %>%
  mutate(stage = "12-24")

# Combine transitions
trans_all <- bind_rows(trans_0_12, trans_12_24)

# Add unique node names
trans_all <- trans_all %>%
  mutate(
    source_node = paste0(source, " (", gsub("-.*", "", stage), "m)"),
    target_node = paste0(target, " (", gsub(".*-", "", stage), "m)")
  )


#Create Pairwise Transition Table: From 0 to 12 Months Directly
trans_0_12 <- wa_apin_dtg_0_19_full %>%
  filter(!is.na(baseline_vl_label) & !is.na(vl_12_label)) %>%
  count(source = baseline_vl_label, target = vl_12_label)

#12 to 24 Months (unchanged)
trans_12_24 <- wa_apin_dtg_0_19_full %>%
  filter(!is.na(vl_12_label) & !is.na(vl_24_label)) %>%
  count(source = vl_12_label, target = vl_24_label)

#Add Stage Info
trans_0_12$stage <- "0-12"
trans_12_24$stage <- "12-24"

#Combine Transitions
trans_all <- bind_rows(
  trans_0_12,
  trans_12_24
)

#Add Time to Node Names (unique source/target names per stage)
trans_all <- trans_all %>%
  mutate(
    source_node = paste0(source, " (", gsub("-.*", "", stage), "m)"),
    target_node = paste0(target, " (", gsub(".*-", "", stage), "m)")
  )

# Step: Create SankeyMATIC strings
sankey_input_0_12_24 <- trans_all %>%
  mutate(
    source_node = paste0(source, " (", gsub("-.*", "", stage), "m)"),
    target_node = paste0(target, " (", gsub(".*-", "", stage), "m)"),
    sankey_line = paste0(source_node, " [", n, "] ", target_node)
  ) %>%
  pull(sankey_line)
#Save text file
writeLines(sankey_input_0_12_24, "sankey_input_0_12_24.txt")
```

\begin{landscape}
\subsubsection{Sankey Diagram of Viral Load Transitions (M0 → M12 → M24)}
The Sankey diagram shows viral load (VL) transitions among children and adolescents living with HIV (CALHIV) from DTG initiation to 12 and 24 months. At baseline, most patients were undetectable (<200 copies/mL) and largely maintained suppression at 12 months. Those with low-level viremia (LLV, 200–999 copies/mL), virological failure (VF, >= 1000 copies/mL), or unknown VL at baseline showed variable trajectories, with some achieving suppression and others remaining viremic or with missing data. LLV patterns were particularly heterogeneous, reflecting intermediate viral control.

Between 12 and 24 months, viral suppression remained stable. Most patients initially undetectable maintained suppression, while many with baseline VF or unknown VL improved. Only a minority transitioned to VF or remained missing, highlighting sustained effectiveness of DTG therapy and partial recovery of follow-up data. Overall, these results demonstrate durable viral control with variable trajectories among patients with intermediate or initially high VL.

```{r fig.align='center', out.width='100%'}
knitr::include_graphics("C:/Users/Emile/Desktop/IeDEA/projet réponse virologique/TRV pwada vEmile Sept25/news file TRV pwada Oct25/sankeymatic_0_12_24.png") 
```
\end{landscape}

```{r}
# :>= 1000 copies (0m) #FF0000 << >>
# :>= 1000 copies (6m) #FF0000  >>
# :>= 1000 copies (12m) #FF0000  >>
# :>= 1000 copies (24m) #FF0000  >>

# :Undetectable (<200) (0m) #1b9e77 >>
# :Undetectable (<200) (6m) #1b9e77 >>
# :Undetectable (<200) (12m) #1b9e77 >>
# :Undetectable (<200) (24m) #1b9e77 >>

# :Low-level viremia (0m) #FFD700 >>
# :Low-level viremia (6m) #FFD700 >>
# :Low-level viremia (12m) #FFD700 >>
# :Low-level viremia (24m) #FFD700 >>

# :Right-censored (12m) #888888 << >>
# :Right-censored (24m) #888888 << >>

# :Unknown (0m) #ADD8E6 << >>
# :Unknown (6m) #ADD8E6 << >>
# :Unknown (12m) #ADD8E6 << >>
# :Unknown (24m) #ADD8E6 << >>
write_csv2(wa_apin_vl_cleaned, "wa_apin_vl_cleaned.csv")
```



```{r include=FALSE}
#\section{models flexmix and randomLCA}
#bdd
##Code pour la charge virale
base_vL_new <- read.csv2("C:/Users/Emile/Desktop/IeDEA/projet réponse virologique/TRV pwada vEmile Sept25/news file TRV pwada Oct25/wa_apin_vl_cleaned.csv")
base_vL_new$dtg_sd <- as.Date(base_vL_new$dtg_sd, format = "%Y-%m-%d")
base_vL_new$rna_d <- as.Date(base_vL_new$rna_d, format = "%Y-%m-%d")
base_vL_new$end_d <- as.Date(base_vL_new$end_d, format = "%Y-%m-%d")

aa <- base_vL_new %>%
  filter(rna_d >= (dtg_sd %m-% months(6)))

base_vL_new %>%
  count( vl_class, name = "n") %>%
  arrange(desc(n))

base_vL_new <- base_vL_new %>%
  mutate(
    vL_mesure = rna_v,
    t_mesure_months = as.numeric(difftime(rna_d, dtg_sd, units = "days")) / 30.4,
    t_mesure_months = if_else(t_mesure_months < 0, 0, t_mesure_months)
  )
#Delete pat == "00152/YA/10/01660E" don't have rna_v at t=~43
base_vL_new <- subset(base_vL_new, !is.na(rna_v))

#vL at baseline(m0)-m6-m12-M24-m36-m48-m60
base_vL_new <- base_vL_new %>%
  group_by(patient) %>%
  mutate(
    nbr_mesure_pat = n_distinct(rna_d)
  ) %>%
  ungroup() %>%
  mutate(
    # Dates cibles
    target_M0  = dtg_sd,
    target_M6  = dtg_sd %m+% months(6),
    target_M12 = dtg_sd %m+% months(12),
    target_M24 = dtg_sd %m+% months(24),
    target_M36 = dtg_sd %m+% months(36),
    target_M48 = dtg_sd %m+% months(48),
    target_M60 = dtg_sd %m+% months(60)
  ) %>%
  group_by(patient) %>%
  mutate(
    # M0 : -6 mois à +14 jours
    vL_m0  = if_else(
      baseline == 1 | t_mesure_months == 0,       # <-- priorité baseline / t_measure_months = 0
      rna_v,
      if_else(
        rna_d >= (target_M0 - months(6)) & rna_d <= (target_M0 + days(14)),
        rna_v[which.min(abs(as.numeric(difftime(rna_d, target_M0, units="days"))))],
        NA_real_
      )
    ),
    
    # M6 : ±3 mois
    vL_m6  = if_else(
      rna_d >= (target_M6 - months(3)) & rna_d <= (target_M6 + months(3)),
      rna_v[which.min(abs(as.numeric(difftime(rna_d, target_M6, units="days"))))],
      NA_real_
    ),
    
    # M12, M24, M36, M48 : ±6 mois
    vL_m12 = if_else(
      rna_d >= (target_M12 - months(6)) & rna_d <= (target_M12 + months(6)),
      rna_v[which.min(abs(as.numeric(difftime(rna_d, target_M12, units="days"))))],
      NA_real_
    ),
    vL_m24 = if_else(
      rna_d > (target_M24 - months(6)) & rna_d <= (target_M24 + months(6)),
      rna_v[which.min(abs(as.numeric(difftime(rna_d, target_M24, units="days"))))],
      NA_real_
    ),
    vL_m36 = if_else(
      rna_d > (target_M36 - months(6)) & rna_d <= (target_M36 + months(6)),
      rna_v[which.min(abs(as.numeric(difftime(rna_d, target_M36, units="days"))))],
      NA_real_
    ),
    vL_m48 = if_else(
      rna_d > (target_M48 - months(6)) & rna_d <= (target_M48 + months(6)),
      rna_v[which.min(abs(as.numeric(difftime(rna_d, target_M48, units="days"))))],
      NA_real_
    ),
    vL_m60 = if_else(
      rna_d > (target_M60 - months(6)) & rna_d <= (target_M60 + months(6)),
      rna_v[which.min(abs(as.numeric(difftime(rna_d, target_M60, units="days"))))],
      NA_real_
    )
  ) %>%
  ungroup() %>%
  select(-starts_with("target_"))
```


```{r include=FALSE}
base_vL_new <- base_vL_new %>%
  mutate(
    vl_m0_class = case_when(
      !is.na(vL_m0) & vL_m0 < 200 ~ 1,
      !is.na(vL_m0) & vL_m0 >= 200 & vL_m0 < 1000 ~ 2,
      !is.na(vL_m0) & vL_m0 >= 1000 ~ 3,
      is.na(vL_m0) ~ 9
    ),
    vl_m6_class = case_when(
      !is.na(vL_m6) & vL_m6 < 200 ~ 1,
      !is.na(vL_m6) & vL_m6 >= 200 & vL_m6 < 1000 ~ 2,
      !is.na(vL_m6) & vL_m6 >= 1000 ~ 3,
      is.na(vL_m6) ~ 9
    ),
    vl_m12_class = case_when(
      !is.na(vL_m12) & vL_m12 < 200 ~ 1,
      !is.na(vL_m12) & vL_m12 >= 200 & vL_m12 < 1000 ~ 2,
      !is.na(vL_m12) & vL_m12 >= 1000 ~ 3,
      is.na(vL_m12) ~ 9
    ),
    vl_m24_class = case_when(
      !is.na(vL_m24) & vL_m24 < 200 ~ 1,
      !is.na(vL_m24) & vL_m24 >= 200 & vL_m24 < 1000 ~ 2,
      !is.na(vL_m24) & vL_m24 >= 1000 ~ 3,
      is.na(vL_m24) ~ 9
    ),
    vl_m36_class = case_when(
      !is.na(vL_m36) & vL_m36 < 200 ~ 1,
      !is.na(vL_m36) & vL_m36 >= 200 & vL_m36 < 1000 ~ 2,
      !is.na(vL_m36) & vL_m36 >= 1000 ~ 3,
      is.na(vL_m36) ~ 9
    ),
    vl_m48_class = case_when(
      !is.na(vL_m48) & vL_m48 < 200 ~ 1,
      !is.na(vL_m48) & vL_m48 >= 200 & vL_m48 < 1000 ~ 2,
      !is.na(vL_m48) & vL_m48 >= 1000 ~ 3,
      is.na(vL_m48) ~ 9
    ),
    vl_m60_class = case_when(
      !is.na(vL_m60) & vL_m60 < 200 ~ 1,
      !is.na(vL_m60) & vL_m60 >= 200 & vL_m60 < 1000 ~ 2,
      !is.na(vL_m60) & vL_m60 >= 1000 ~ 3,
      is.na(vL_m60) ~ 9
    )
  )
```

```{r include=FALSE}
base_vL_new <- base_vL_new %>%
  mutate(
    vL_mesure = if_else(
      vL_mesure <= 0,              
      floor(runif(n(), min = 1, max = 199)), #aléa entre 1 & 199        
      vL_mesure))

#ctrL
tbl_nbr_measur <- base_vL_new %>%
  group_by(patient) %>%
  summarise(nbmesr_rna_v = sum(!is.na(vL_mesure)), .groups = "drop")
```


```{r include=FALSE}
base_modL <- base_vL_new %>% select(pat, patient, program, vL_mesure, t_mesure_months)

#outcome
base_modL <- base_modL %>%
  mutate(outcome = ifelse(vL_mesure > 200, 1, 0))

set.seed(123456)
#base_modL$outcome <- as.factor(base_modL$outcome)
base_modL$outcome_matrix <- cbind(base_modL$outcome, 1-base_modL$outcome)

set.seed(123456)
mod3 <- flexmix(outcome_matrix ~ t_mesure_months + I(t_mesure_months^2) | patient,
               model = FLXMRglm(family = "binomial"),
               data=base_modL, k=3)

#logLik, AIC et BIC
sum3mary <- data.frame(
  Metric = c("Log-Likelihood", "AIC", "BIC"),
  Value = c(logLik(mod3), AIC(mod3), BIC(mod3))
)
#sum3mary

set.seed(123456)
mod4 <- flexmix(outcome_matrix ~ t_mesure_months + I(t_mesure_months^2) | patient,
               model = FLXMRglm(family = "binomial"),
               data=base_modL, k=4)
sum4mary <- data.frame(
  Metric = c("Log-Likelihood", "AIC", "BIC"),
  Value = c(logLik(mod4), AIC(mod4), BIC(mod4))
)
#sum4mary

set.seed(123456)
mod5 <- flexmix(outcome_matrix ~ t_mesure_months + I(t_mesure_months^2) | patient,
               model = FLXMRglm(family = "binomial"),
               data=base_modL, k=5)

sum5mary <- data.frame(
  Metric = c("Log-Likelihood", "AIC", "BIC"),
  Value = c(logLik(mod5), AIC(mod5), BIC(mod5))
)

```

\newpage
\begin{landscape}
\section{Models flexmix and randomLCA}
\subsection{flexmix}
\subsubsection{flexmix model in 3 class}
```{r}
knitr::kable(sum3mary, caption = "Résumé du modèle FlexMix") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "center")
# Extraire les probabilités d'appartenance aux classes
probabilities <- posterior(mod3)  # Une matrice avec une colonne pour chaque classe
# Identifier la classe dominante pour chaque observation
dominant_class <- apply(probabilities, 1, which.max)  # Renvoie 1, 2, 3 ou 4

# Ajouter la classe dominante et sa probabilité à base_modL
base_modL$class3 <- dominant_class
base_modL$prob_class <- probabilities[cbind(1:nrow(probabilities), dominant_class)]


base_modL <- base_modL %>% arrange(patient)
tab_probpost <- base_modL 

tab_probpost <- tab_probpost  %>%
  group_by(patient) %>%
  slice(1) 
#table(tab_probpost$class3)


# Calculer le nombre d'observations par classe
obs_per_class <- table(tab_probpost$class3)

# Créer les labels de classe avec les nombres d'observations
class_labels <- paste0(1:3, " : N = ", obs_per_class)

tblgraph <- base_modL[, c("t_mesure_months", "patient", "vL_mesure", "class3")]
# Tracer le graphique avec ggplot
flex3 <- ggplot(tblgraph, aes(x = t_mesure_months, y = log10(vL_mesure), color = factor(class3))) +
  geom_smooth(aes(group = class3), method = "loess", size = 1.5, se = FALSE) +  
  labs(x = "Time since ART initiation (months)", 
       y = "Viral Load (log10)", color = "") +
  scale_x_continuous(breaks = seq(0, 24, by = 3), limits = c(0, 26)) +  
  geom_hline(yintercept = log10(1000), linetype = "dashed", color = "black", size = 0.3) +  
  geom_hline(yintercept = log10(200), linetype = "dashed", color = "black", size = 0.3) + 
  #geom_vline(xintercept = 12, linetype = "dotted", color = "red", size = 0.3)+
  scale_color_manual(
    values = c("black", "red", "blue"),  # Couleurs pour 3 classes
    labels = class_labels  # Labels incluant les nombres d'observations par classe
  ) +        
 theme_minimal(base_size = 10) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal",
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 12),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", size = 0.8),
    axis.ticks = element_line(color = "black", size = 0.8),
    axis.ticks.length = unit(0.2, "cm"),
    axis.text = element_text(color = "black", size = 12)
  ) +
  annotate("text", x = 26, y = log10(1000), label = "log10(1000)", color = "black", hjust = 0.5, vjust = -0.5, size = 4) +
  annotate("text", x = 26, y = log10(200), label = "log10(200)", color = "black", hjust = 0.5, vjust = -0.5, size = 4)


ggsave("flex3.png", plot = flex3, width = 14, height = 6)

```

```{r fig.align='center', out.width='100%'}
knitr::include_graphics("flex3.png") 
```
\end{landscape}

\newpage

The FlexMix model with \textbf{three latent classes} was applied to longitudinal viral load data using a binomial family, modeling the probability of having a detectable viral load (\(\geq 200\) copies/mL) over time. Time since DTG initiation (in months) and its quadratic term were included as predictors to capture both linear and non-linear dynamics of viral response. This 3-class model summarizes the main patterns observed in the cohort and highlights three dominant virological trajectories.

\begin{itemize}
    \item \textbf{Profile 1 (N = 1670)}: Patients maintained \textbf{undetectable viral load} (\(<200\) copies/mL) over the entire 24-month follow-up period. This is the largest class and represents individuals with a stable and sustained virological suppression from treatment initiation. This trajectory suggests early effective ART initiation, good adherence, and robust treatment efficacy.
    \item \textbf{Profile 2 (N = 812)}: Participants exhibited \textbf{persistently high viral load} (\(\geq 1000\) copies/mL) throughout the follow-up period. This trajectory likely reflects sustained virological failure, potentially linked to adherence problems, delayed ART initiation, or resistance issues. This group may require intensified clinical monitoring and targeted interventions.
    \item \textbf{Profile 3 (N = 1609)}: This class is characterized by a \textbf{sharp decline from high baseline viral load} (\(\geq 1000\) copies/mL) within the first month after DTG initiation, reaching undetectable levels (\(<200\) copies/mL) by 6 months and remaining stable thereafter. This pattern reflects rapid virological responders with early and sustained treatment success.
\end{itemize}


The 3-class FlexMix model captures the \textbf{main structure of virological heterogeneity} with fewer latent classes while preserving clinically meaningful patterns. Profile 1 represents stable suppression, Profile 2 persistent failure, and Profile 3 rapid response. From a modeling standpoint, this reduced classification emphasizes the contrast between favorable and unfavorable virological dynamics, facilitating interpretation and potential clinical stratification.

Clinically, these three trajectories correspond to \textbf{key response patterns under DTG}: early suppression, non-response, and sustained suppression from baseline. Statistically, this more parsimonious model may be useful for targeted risk stratification and prediction while avoiding overfitting compared to models with a higher number of classes.

\newpage
\begin{landscape}
\subsubsection{flexmix model in 4 class}
```{r}
knitr::kable(sum4mary, caption = "Résumé du modèle FlexMix") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "center")
# Extraire les probabilités d'appartenance aux classes
probabilities <- posterior(mod4)  # mod4 = ton modèle flexmix à 4 classes
dominant_class <- apply(probabilities, 1, which.max)

# Ajouter les infos dans base_modL
base_modL$class4 <- dominant_class
base_modL$prob_class <- probabilities[cbind(1:nrow(probabilities), dominant_class)]

# Trier et résumer par patient
base_modL <- base_modL %>% arrange(patient)
tab_probpost <- base_modL %>%
  group_by(patient) %>%
  slice(1)

# Effectif par classe
obs_per_class <- table(tab_probpost$class4)
class_labels <- paste0(1:4, " : N = ", obs_per_class)

# Extraire les variables utiles pour le graphique
tblgraph <- base_modL[, c("t_mesure_months", "patient", "vL_mesure", "class4")]

# Tracer le graphique
flex4 <- ggplot(tblgraph, aes(x = t_mesure_months, y = log10(vL_mesure), color = factor(class4))) +
  geom_smooth(aes(group = class4), method = "loess", size = 1.5, se = FALSE) +
  labs(
    x = "Time since ART initiation (months)",
    y = "Viral Load (log10)",
    color = ""
  ) +
  scale_x_continuous(breaks = seq(0, 24, by = 3), limits = c(0, 26)) +
  geom_hline(yintercept = log10(1000), linetype = "dashed", color = "black", size = 0.3) +
  geom_hline(yintercept = log10(200), linetype = "dashed", color = "black", size = 0.3) +
  #geom_vline(xintercept = 12, linetype = "dotted", color = "red", size = 0.3) +
  scale_color_manual(
    values = c("blue", "black", "darkorange", "red"),
    #values = c("black", "blue", "red", "green"),
    #values = c("#1b9e77", "#d95f02", "#7570b3", "#e7298a"),  # ✅ 4 belles couleurs
    labels = class_labels
  ) +
  theme_minimal(base_size = 10) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal",
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 12),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", size = 0.8),
    axis.ticks = element_line(color = "black", size = 0.8),
    axis.ticks.length = unit(0.2, "cm"),
    axis.text = element_text(color = "black", size = 12)
  ) +
  annotate("text", x = 26, y = log10(1000), label = "log10(1000)", color = "black", hjust = 0.5, vjust = -0.5, size = 4) +
  annotate("text", x = 26, y = log10(200), label = "log10(200)", color = "black", hjust = 0.5, vjust = -0.5, size = 4)


# Sauvegarde et affichage
ggsave("flex4.png", plot = flex4, width = 14, height = 6)

```

```{r fig.align='center', out.width='100%'}
knitr::include_graphics("flex4.png") 
```
\end{landscape}

\newpage
The FlexMix model with \textbf{four latent classes} was applied to longitudinal viral load data using a binomial family to model the probability of having a detectable viral load (\(\geq 200\) copies/mL) over time. This model provides an intermediate granularity between the more parsimonious 3-class model and the more detailed 5-class solution, capturing key virological response trajectories under DTG-based ART.

\begin{itemize}
    \item \textbf{Profile 1 (N = 1023)}: Patients started with high viral loads (\(\geq 1000\) copies/mL) and subsequently stabilized at an \textbf{intermediate level}, remaining detectable but not returning to undetectable levels. This trajectory reflects a \textbf{partial or suboptimal virological response}, possibly associated with delayed suppression or adherence issues.
    \item \textbf{Profile 2 (N = 1073)}: Individuals in this class maintained \textbf{undetectable viral load} (\(<200\) copies/mL) over the entire 24-month follow-up period, indicating early and sustained suppression and representing a stable responder group.
    \item \textbf{Profile 3 (N = 1560)}: Participants began in the \textbf{intermediate viral load range} (between undetectable and \(\geq 1000\) copies/mL) but experienced a \textbf{progressive decline to undetectable levels} (\(<200\) copies/mL) which remained stable thereafter. This trajectory corresponds to a delayed but successful virological response.
    \item \textbf{Profile 4 (N = 435)}: Patients exhibited \textbf{persistently high viral load} (\(\geq 1000\) copies/mL) throughout the 24 months of follow-up, indicating sustained virological failure and identifying a high-risk group in need of targeted clinical interventions.
\end{itemize}

The 4-class FlexMix model reveals a more nuanced structure of virological heterogeneity compared to the 3-class solution by distinguishing an \textbf{intermediate or partial responder group} (Profile 1) from the rapid and sustained responders (Profile 2 and 3) and non-responders (Profile 4). This classification captures clinically meaningful differences in viral suppression dynamics.

From a statistical perspective, this intermediate model provides a balance between parsimony and clinical interpretability. It clearly separates \textbf{sustained suppression}, \textbf{delayed suppression}, \textbf{partial response}, and \textbf{persistent failure}. Clinically, these profiles can help guide patient stratification, identify those at risk of poor outcomes, and optimize monitoring and intervention strategies.


\newpage
\begin{landscape}
\subsubsection{flexmix model in 5 class}
```{r}
knitr::kable(sum5mary, caption = "Résumé du modèle FlexMix") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "center")
# Extraire les probabilités d'appartenance aux classes
probabilities <- posterior(mod5)  # mod5 = ton modèle flexmix à 5 classes
dominant_class <- apply(probabilities, 1, which.max)

# Ajouter les infos dans base_modL
base_modL$class5 <- dominant_class
base_modL$prob_class <- probabilities[cbind(1:nrow(probabilities), dominant_class)]

# Trier et résumer par patient
base_modL <- base_modL %>% arrange(patient)
tab_probpost <- base_modL %>%
  group_by(patient) %>%
  slice(1)

# Effectif par classe
obs_per_class <- table(tab_probpost$class5)
class_labels <- paste0(1:5, " : N = ", obs_per_class)

# Extraire les variables utiles pour le graphique
tblgraph <- base_modL[, c("t_mesure_months", "patient", "vL_mesure", "class5")]

# Tracer le graphique
flex5 <- ggplot(tblgraph, aes(x = t_mesure_months, y = log10(vL_mesure), color = factor(class5))) +
  geom_smooth(aes(group = class5), method = "loess", size = 1.5, se = FALSE) +
  labs(
    x = "Time since ART initiation (months)",
    y = "Viral Load (log10)",
    color = ""
  ) +
  scale_x_continuous(breaks = seq(0, 24, by = 3), limits = c(0, 26)) +
  geom_hline(yintercept = log10(1000), linetype = "dashed", color = "black", size = 0.3) +
  geom_hline(yintercept = log10(200), linetype = "dashed", color = "black", size = 0.3) +
  #geom_vline(xintercept = 12, linetype = "dotted", color = "red", size = 0.3) +
  scale_color_manual(
    values = c("darkorange", "blue", "red", "black", "#E127D8"), 
    #values = c("#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"),  # ✅ 5 couleurs distinctes
    labels = class_labels
  ) +
  theme_minimal(base_size = 10) +
  theme(
    legend.position = "top",
    legend.direction = "horizontal",
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 12),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", size = 0.8),
    axis.ticks = element_line(color = "black", size = 0.8),
    axis.ticks.length = unit(0.2, "cm"),
    axis.text = element_text(color = "black", size = 12)
  ) +
  annotate("text", x = 26, y = log10(1000), label = "log10(1000)", color = "black", hjust = 0.5, vjust = -0.5, size = 4) +
  annotate("text", x = 26, y = log10(200), label = "log10(200)", color = "black", hjust = 0.5, vjust = -0.5, size = 4)


# Sauvegarde et affichage
ggsave("flex5.png", plot = flex5, width = 14, height = 6)

```

```{r fig.align='center', out.width='100%'}
knitr::include_graphics("flex5.png") 
```
\end{landscape}
\newpage
The FlexMix model was applied to longitudinal viral load data using a \textbf{binomial family} to model the probability of having a detectable viral load (\(\geq 200\) copies/mL) over time. Time since DTG initiation (in months) and its quadratic term were included as predictors to capture both linear and non-linear trends. This modeling strategy allowed the identification of \textbf{five distinct latent classes}, each representing a specific virological trajectory among children and adolescents on DTG-based ART.

\begin{itemize}
    \item \textbf{Profile 1 (N = 484)}: Initially detectable viral load with a trend toward increasing or sustained high levels (\(\geq 1000\) copies/mL) over 24 months. This pattern may reflect treatment failure, adherence issues, or late presentation, highlighting the need for close clinical monitoring.
    \item \textbf{Profile 2 (N = 737)}: High baseline viral load (\(\geq 1000\) copies/mL) with a gradual decline to undetectable levels (\(<200\) copies/mL) by the end of follow-up. This suggests delayed but effective treatment response, potentially due to initial high baseline VL or other clinical factors influencing time to suppression.
    \item \textbf{Profile 3 (N = 250)}: Persistently high viral load (\(\geq 1000\) copies/mL) throughout the 24 months, indicating sustained virological failure. This profile is of clinical concern and may reflect poor adherence, drug resistance, or late ART initiation.
    \item \textbf{Profile 4 (N = 2031)}: Stable undetectable viral load (\(<200\) copies/mL) from baseline to 24 months, representing optimal and sustained response to DTG, likely linked to early treatment initiation, good adherence, and robust regimen efficacy.
    \item \textbf{Profile 5 (N = 589)}: High baseline viral load (\(\geq 1000\) copies/mL) with a rapid drop to undetectable levels after 6 months, maintained over time. This reflects rapid responders with strong early virological control.
\end{itemize}

From a modeling perspective, the FlexMix latent class approach allowed us to \textbf{partition heterogeneity in treatment response} without imposing a single average trajectory on the population. The inclusion of the quadratic time effect was crucial to capture early declines and plateaus observed in some classes (e.g., Profiles 2 and 5).

Profiles 1 and 3 correspond to suboptimal or worsening trajectories, potentially signaling risk groups who may benefit from targeted interventions (e.g., adherence support, resistance testing). Conversely, Profiles 4 and 5 reflect favorable virological dynamics with early or sustained suppression, while Profile 2 indicates a delayed but eventual favorable outcome.

Clinically, these findings underscore the heterogeneity of viral suppression patterns under DTG and the importance of early baseline characteristics (e.g., viral load) in predicting long-term outcomes. Statistically, they highlight the added value of latent class modeling over conventional mixed models for uncovering meaningful patient subgroups.


```{r}
#table(tab_probpost$class3)
#table(tab_probpost$class4)
#table(tab_probpost$class5)
```

\newpage
\subsection{Model fit statistics for latent class models with 3 to 5 classes}
\subsubsection{Table metrics}
\begin{table}[!ht]
\centering
\begin{tabular}{cccc}
\toprule
\textbf{metric} & \textbf{3-class} & \textbf{4-class} & \textbf{5-class} \\
\midrule
Log-Likelihood & $-10922.17$ & $-10819.90$ & $-10792.82$ \\
AIC            & $21866.33$ & $21669.79$  & $21623.64$  \\
BIC            & $21954.82$ & $21790.46$  & $21776.48$  \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Model selection.}  
Among the three candidate models, the 5-class model achieved the lowest AIC and BIC values, indicating the best statistical fit to the data. Beyond the numerical improvement, the 5-class solution provides clinically meaningful distinctions between different virological response trajectories, particularly separating groups with delayed response, sustained suppression, and persistent viremia. This finer granularity captures the heterogeneity of treatment responses more accurately and offers better clinical interpretability. Therefore, the 5-class model was selected as the final model for subsequent analyses.

```{r}
## BAse de données pour le modèle
tbl_modL <- tbl_describ %>% left_join(base_modL %>% select(patient, class3, class4, class5), by = "patient") %>%
  arrange(patient) %>%
  group_by(patient) %>%
  slice(1) %>%
  ungroup()


# classes de référence
tbl_modL$program <- as.factor(tbl_modL$program)
tbl_modL$sex <- as.factor(tbl_modL$sex)
tbl_modL$baseline_vl_label <- as.factor(tbl_modL$baseline_vl_label)
tbl_modL$age_cat <- as.factor(tbl_modL$age_cat) 
tbl_modL$prev_art_class_vf <- as.factor(tbl_modL$prev_art_class_vf)

tbl_modL$class3 <- as.factor(tbl_modL$class3)
tbl_modL$class4 <- as.factor(tbl_modL$class4)
tbl_modL$class5 <- as.factor(tbl_modL$class5)

tbl_modL$program <- relevel(tbl_modL$program, ref = "CEPREF")
tbl_modL$sex <- relevel(tbl_modL$sex, ref = "Male")
tbl_modL$age_cat <- relevel(tbl_modL$age_cat, ref = "<5")
tbl_modL$baseline_vl_label <- relevel(tbl_modL$baseline_vl_label, ref = "Undetectable < 200")
tbl_modL$prev_art_class_vf <- relevel(tbl_modL$prev_art_class_vf, ref = "NNRTI")

tbl_modL$class3 <- relevel(tbl_modL$class3, ref = "1")

#tbl_modL$class4 <- relevel(tbl_modL$class4, ref = "3")
tbl_modL$class5 <- relevel(tbl_modL$class5, ref = "4")
```

```{r include=FALSE}
#tab_studyP$class <- model_Nber_cL$clust [avant de faire le model logistik]
mod_cL5 <- nnet::multinom(
   class5 ~ sex  + baseline_vl_label + age_cat + prev_art_class_vf  + program, #
   data = tbl_modL,
   maxit = 500,
   trace = TRUE)

tbl <- tbl_regression(mod_cL5, exponentiate = TRUE)

multinom_table_wide <- function(model, exponentiate = TRUE) {
  if (!inherits(model, "multinom")) {
    stop("Le modèle doit être un objet de type `nnet::multinom()`.")
  }

  tbl <- gtsummary::tbl_regression(model, exponentiate = exponentiate)
  outcome_levels <- unique(tbl$table_body$groupname_col)
  tbl_list <- purrr::map(outcome_levels, function(lvl) {
    gtsummary::modify_table_body(
      tbl,
      ~dplyr::filter(.x, .data$groupname_col == lvl) %>%
        dplyr::ungroup() %>%
        dplyr::select(-.data$groupname_col)
    )
  })
  gtsummary::tbl_merge(
    tbl_list,
    tab_spanner = outcome_levels %>% paste0("", ., "")
  )
}
tbl_modL <- multinom_table_wide(mod_cL5) %>%
  as_gt() %>%
  opt_table_font(size = 10)
```

```{r eval=FALSE, include=FALSE}
tbl_modL %>% as_latex() %>% as.character() %>% cat() #% ou \footnotesize, \tiny, \small selon ton besoin
```
\newpage
\begin{landscape}
\section{Model logistique multinomiale}
\subsection{ModeL global}
\subsubsection{ModeL with 5 class}

\begin{table}[!t]
\centering
\scriptsize  
\begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}lcccccccccccc}
\toprule
 & \multicolumn{3}{c}{1} & \multicolumn{3}{c}{2} & \multicolumn{3}{c}{3} & \multicolumn{3}{c}{5} \\ 
\cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-10} \cmidrule(lr){11-13}
\textbf{} & \textbf{OR}\textsuperscript{\textit{1}} & \textbf{95\% CI}\textsuperscript{\textit{1}} & \textbf{p-value} & 
\textbf{OR}\textsuperscript{\textit{1}} & \textbf{95\% CI}\textsuperscript{\textit{1}} & \textbf{p-value} & 
\textbf{OR}\textsuperscript{\textit{1}} & \textbf{95\% CI}\textsuperscript{\textit{1}} & \textbf{p-value} & 
\textbf{OR}\textsuperscript{\textit{1}} & \textbf{95\% CI}\textsuperscript{\textit{1}} & \textbf{p-value} \\ 
\midrule
\textbf{sex} &  &  &  &  &  &  &  &  &  &  &  &  \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Male & — & — &  & — & — &  & — & — &  & — & — &  \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  FeMale & 1.02 & 0.83, 1.26 & 0.9 & 1.01 & 0.82, 1.25 & >0.9 & 0.86 & 0.63, 1.17 & 0.3 & 0.94 & 0.75, 1.18 & 0.6 \\ 
\textbf{baseline\_vL} &  &  &  &  &  &  &  &  &  &  &  &  \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  Undetectable < 200 & — & — &  & — & — &  & — & — &  & — & — &  \\ 
    \ \ \ \ \ Low level viremia [200-1000[ & 34,3 & 23,22, 50,8 & <0.001 & 310,4 & 225,3, 427,8 & <0.001 & 772,1 & 423,22, 1,408 & <0.001 & 428,1 & 301,2, 608,6 & <0.001 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  $\geq$ 1000 & 105,4 & 80,5, 138,0 & <0.001 & 670,4 & 514,8, 873,0 & <0.001 & 3,316 & 1,963, 5,598 & <0.001 & 92,540 & 696,2, 1,239 & <0.001 \\
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  Unknown & 1.90 & 1.46, 2.48 & <0.001 & 4.96 & 3.70, 6.65 & <0.001 & 16.4 & 7.94, 33.8 & <0.001 & 6.80 & 4.88, 9.49 & <0.001 \\ 
\textbf{age\_cat} &  &  &  &  &  &  &  &  &  &  &  &  \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  <5 & — & — &  & — & — &  & — & — &  & — & — &  \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  5-9 & 0.92 & 0.54, 1.55 & 0.7 & 0.62 & 0.38, 0.99 & 0.043 & 0.58 & 0.28, 1.18 & 0.13 & 1.00 & 0.56, 1.77 & >0.9 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  10-14 & 0.89 & 0.54, 1.49 & 0.7 & 0.69 & 0.44, 1.09 & 0.11 & 0.99 & 0.51, 1.90 & >0.9 & 1.25 & 0.72, 2.17 & 0.4 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  15-19 & 0.66 & 0.40, 1.11 & 0.12 & 0.42 & 0.26, 0.66 & <0.001 & 0.83 & 0.43, 1.60 & 0.6 & 0.68 & 0.39, 1.18 & 0.2 \\ 
\textbf{prev\_art\_class\_vf} &  &  &  &  &  &  &  &  &  &  &  &  \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  NNRTI & — & — &  & — & — &  & — & — &  & — & — &  \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  INSTI & 0.00 & 0.00, 0.00 & <0.001 & 2.01 & 0.17, 23.7 & 0.6 & 0.00 & 0.00, 0.00 & <0.001 & 0.00 & 0.00, 0.00 & <0.001 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  naive & 0.69 & 0.48, 0.98 & 0.041 & 0.72 & 0.51, 1.02 & 0.066 & 0.83 & 0.50, 1.37 & 0.5 & 0.37 & 0.25, 0.54 & <0.001 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  NRTIs & 0.93 & 0.70, 1.24 & 0.6 & 1.14 & 0.85, 1.53 & 0.4 & 1.00 & 0.64, 1.55 & >0.9 & 0.91 & 0.67, 1.24 & 0.6 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  PI & 1.00 & 0.74, 1.36 & >0.9 & 1.30 & 0.95, 1.77 & 0.10 & 1.66 & 1.08, 2.55 & 0.020 & 0.66 & 0.47, 0.92 & 0.016 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  reinitiator & 3.56 & 0.17, 75.7 & 0.4 & 2.02 & 0.08, 51.8 & 0.7 & 0.00 & 0.00, 0.00 & <0.001 & 0.00 & 0.00, 0.00 & <0.001 \\ 
\textbf{program} &  &  &  &  &  &  &  &  &  &  &  &  \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  CEPREF & — & — &  & — & — &  & — & — &  & — & — &  \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  ABEOKUTA & 1.06 & 0.55, 2.08 & 0.9 & 1.43 & 0.72, 2.82 & 0.3 & 2.09 & 0.86, 5.06 & 0.10 & 2.44 & 1.18, 5.08 & 0.017 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  AKURE & 0.77 & 0.43, 1.35 & 0.4 & 1.15 & 0.64, 2.05 & 0.6 & 0.64 & 0.27, 1.50 & 0.3 & 2.02 & 1.06, 3.84 & 0.032 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  CHUC & 1.20 & 0.68, 2.10 & 0.5 & 1.14 & 0.59, 2.20 & 0.7 & 1.95 & 0.82, 4.62 & 0.13 & 1.39 & 0.66, 2.94 & 0.4 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  CHUY & 1.02 & 0.58, 1.78 & >0.9 & 1.65 & 0.91, 3.01 & 0.10 & 2.14 & 0.98, 4.71 & 0.058 & 1.08 & 0.52, 2.28 & 0.8 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  CIRBA & 0.70 & 0.39, 1.26 & 0.2 & 0.46 & 0.22, 0.94 & 0.032 & 0.23 & 0.07, 0.73 & 0.012 & 0.91 & 0.43, 1.92 & 0.8 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  CNHU & 0.52 & 0.27, 1.00 & 0.049 & 0.67 & 0.35, 1.30 & 0.2 & 1.10 & 0.48, 2.50 & 0.8 & 0.71 & 0.33, 1.50 & 0.4 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  GABRIEL & 0.52 & 0.31, 0.90 & 0.018 & 0.75 & 0.43, 1.33 & 0.3 & 0.39 & 0.17, 0.88 & 0.023 & 0.97 & 0.51, 1.84 & >0.9 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  JOS & 1.72 & 1.05, 2.83 & 0.033 & 1.83 & 1.03, 3.22 & 0.038 & 1.57 & 0.73, 3.40 & 0.2 & 1.46 & 0.75, 2.83 & 0.3 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  KBTH & 0.76 & 0.35, 1.61 & 0.5 & 0.93 & 0.43, 1.99 & 0.8 & 0.94 & 0.36, 2.46 & >0.9 & 0.76 & 0.33, 1.78 & 0.5 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  MAKURDI & 1.69 & 1.06, 2.69 & 0.027 & 2.24 & 1.34, 3.77 & 0.002 & 1.29 & 0.63, 2.65 & 0.5 & 4.52 & 2.54, 8.04 & <0.001 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  NIMR & 0.02 & 0.00, 0.14 & <0.001 & 0.10 & 0.03, 0.29 & <0.001 & 0.02 & 0.00, 0.21 & <0.001 & 0.14 & 0.05, 0.42 & <0.001 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  TOKOIN & 0.29 & 0.10, 0.90 & 0.032 & 0.98 & 0.45, 2.14 & >0.9 & 0.76 & 0.22, 2.62 & 0.7 & 0.18 & 0.04, 0.83 & 0.028 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  UCH & 2.72 & 1.55, 4.78 & <0.001 & 3.24 & 1.76, 5.97 & <0.001 & 2.12 & 0.97, 4.65 & 0.061 & 2.07 & 1.02, 4.18 & 0.043 \\ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  YALGADO & 0.85 & 0.45, 1.59 & 0.6 & 0.88 & 0.45, 1.71 & 0.7 & 0.39 & 0.13, 1.19 & 0.10 & 1.49 & 0.73, 3.05 & 0.3 \\ 
\bottomrule
\end{tabular*}
\begin{minipage}{\linewidth}
\scriptsize
\end{minipage}
\end{table}

\end{landscape}



\newpage
\section{Conclusions}

The FlexMix analysis identified five distinct viral load trajectories among children and adolescents on DTG-based ART. Profile 1 (N=484) showed initially detectable viral load reaching $\geq 1000$ copies/mL, while Profile 2 (N=737) started high ($\geq 1000$ copies/mL) but gradually declined to undetectable ($<200$ copies/mL). Profile 3 (N=250) remained persistently high ($\geq 1000$ copies/mL), Profile 4 (N=2031) maintained undetectable levels ($<200$ copies/mL) throughout, and Profile 5 (N=589) experienced a rapid drop to undetectable after 6 months, which was sustained to 24 months. These trajectories highlight the wide variability in individual virological responses under DTG treatment.

Multivariable analysis showed that baseline viral load was the strongest predictor of profile membership, with higher initial values associated with persistently elevated or delayed-response trajectories. Age, prior ART class, and program site also significantly influenced profile allocation, while sex had no effect. Overall, the results underscore the heterogeneity of long-term viral load trajectories and identify key demographic and treatment factors that predict virological outcomes under DTG-based therapy.


```{r}

```


